https://github.com/google/bloaty

--

scan to improve panic and exception handling like force unwrap and expect.

---

implement self update logic for vtcode.

---

more PTY truncate display in TUI, reference:

example

```
Ran git diff --stat
  └  docs/project/TODO.md                               |   6 +
diff --git a/src/agent/runloop/unified/turn/tool_outcomes/execution_result.rs b/src/agent/runloop/
    unified/turn/tool_outcomes/execution_result.rs
"… +9 lines"
                  .push(uni::Message::system(block_reason.clone()));
                 return Ok(Some(TurnHandlerOutcome::Break(TurnLoopResult::Blocked {
```

the key is truncated lines summarize "+9 lines" and the full content is not shown in TUI, but the agent can still access the full content when needed.

```

• Ran cargo test spool_chunk_read_path_detects_spooled_read_calls -- --nocapture
  └     Blocking waiting for file lock on package cache
        Blocking waiting for file lock on package cache
    … +346 lines
    finished in 0.00s



• Ran cargo check
  └    Compiling vtcode-config v0.82.1 (/Users/vinhnguyenxuan/Developer/
        Finished `dev` profile [unoptimized] target(s) in 57.13s

• Ran cargo test -p vtcode-config --no-run
  └     Blocking waiting for file lock on package cache
        Blocking waiting for file lock on package cache
    … +21 lines
      Executable tests/subagent_loading.rs (target/debug/deps/
    subagent_loading-19ca9abe89c74e0a)
```

---

review and revise ask_user_question

--

don't show full readfile output in TUI, only show the first few lines and indicate that there are more lines. try to optimize TUI display for large outputs. and make sure agent can and still have full context. optimize agent content window

---

```
{
  "metadata": {
    "workspace_label": "vtcode",
    "workspace_path": "/Users/vinhnguyenxuan/Developer/learn-by-doing/vtcode",
    "model": "glm-5:cloud",
    "provider": "ollama",
    "theme": "ciapre-dark",
    "reasoning_effort": "low",
    "loaded_skills": []
  },
  "started_at": "2026-02-24T00:25:36.885076Z",
  "ended_at": "2026-02-24T00:31:42.782088Z",
  "total_messages": 2,
  "distinct_tools": [
    "unified_file",
    "unified_search"
  ],
  "transcript": [
    "Switched to Plan Mode",
    "make a plan to improve system prompt",
    "LLM request failed: Provider error: you (vinhnx) have reached your weekly usage limit, please wait or upgrade to continue",
    "Selected GLM-5 (Novita) (zai-org/GLM-5:novita) from Hugging Face.",
    "Hugging Face uses HF_TOKEN (stored in workspace .env) and honors HUGGINGFACE_BASE_URL (default: https://router.huggingface.co/v1).",
    "Model set to GLM-5 (Novita) (zai-org/GLM-5:novita) via Hugging Face.",
    "make a plan to improve system prompt",
    "  I'll explore the codebase to understand the current system prompt structure and identify improvement opportunities.",
    "• Search text Use Unified search",
    "  └ Pattern: system.*prompt|SYSTEM_PROMPT",
    "• Search text Use Unified search",
    "  └ Pattern: system\\.rs|SYSTEM|system_prompt",
    "• Search text Use Unified search",
    "  └ Pattern: vtcode-core/src/prompts/system",
    "• Read file vtcode-core/src/prompts/system.rs",
    "    //! System instructions and prompt management",
    "    //!",
    "    //! # VT Code System Prompts",
    "    //!",
    "    //! Single source of truth for all system prompt variants with unified token constants.",
    "    //!",
    "    //! ## Token Constants (Unified)",
    "    //!",
    "    //! All token thresholds are unified with authoritative values from:",
    "    //! - `crate::core::token_constants`: Warning (75%), Alert (85%), Compact (90%), Checkpoint (95%)",
    "    //! - `crate::core::context_optimizer`: Output optimization based on thresholds",
    "    //! - `crate::core::token_constants::MAX_TOOL_RESPONSE_TOKENS`: 25,000 tokens per tool",
    "    //!",
    "    //! This ensures consistent token management across:",
    "    //! - System prompts (documented in DEFAULT_SYSTEM_PROMPT)",
    "    //! - Context optimization (ContextOptimizer)",
    "    //! - Agent decision-making",
    "    //!",
    "    //! ## Prompt Variants",
    "    //!",
    "    //! - `DEFAULT_SYSTEM_PROMPT`: Production prompt (~500 lines, references unified budgets)",
    "    //! - `DEFAULT_LIGHTWEIGHT_PROMPT`: Resource-constrained (~57 lines)",
    "    //! - `DEFAULT_SPECIALIZED_PROMPT`: Complex refactoring (~100 lines)",
    "    use crate::config::constants::{",
    "        instructions as instruction_constants, project_doc as project_doc_constants,",
    "    };",
    "    // NOTE: Token budget constants (COMPACT_THRESHOLD, CHECKPOINT_THRESHOLD, etc.) are",
    "    // documented in the system prompt and come from:",
    "    // - TokenBudgetConfig defaults: 75% warning, 85% alert",
    "    // - ContextOptimizer: 90% compact, 95% checkpoint",
    "    // - MAX_TOOL_RESPONSE_TOKENS: 25,000 tokens per tool call",
    "    use crate::gemini::Content;",
    "    use crate::instructions::{InstructionBundle, InstructionScope, read_instruction_bundle};",
    "    use crate::project_doc::read_project_doc;",
    "    use crate::prompts::context::PromptContext;",
    "    use crate::prompts::guidelines::generate_tool_guidelines;",
    "    use crate::prompts::output_styles::OutputStyleApplier;",
    "    use crate::prompts::system_prompt_cache::PROMPT_CACHE;",
    "    use crate::prompts::temporal::generate_temporal_context;",
    "    use dirs::home_dir;",
    "    use std::env;",
    "    use std::fmt::Write as _;",
    "    use std::path::Path;",
    "    use tracing::warn;",
    "    /// Unified tool guidance referenced by all prompt variants to reduce duplication",
    "    const UNIFIED_TOOL_GUIDANCE: &str = r#\"**Search & exploration**:",
    "    - Prefer `unified_search` (action='grep') for fast searches over repeated `read` calls",
    "    - Use `unified_search` (action='intelligence') for semantic queries",
    "    - Read complete files once; don't re-invoke `read` on same file",
    "    - For spooled outputs, advance `read_file`/`unified_file` offsets; never repeat identical chunk args",
    "    - If 2+ chunk reads stall progress, switch to `grep_file`/`unified_search` and summarize before more",
    "    - Use `unified_exec` with `rg` (ripgrep) for patterns—much faster than `grep`",
    "    **Code modification**:",
    "    - `unified_file` (action='edit') for surgical changes; action='write' for new or full replacements",
    "    - After a successful patch/edit, continue without redundant re-reads",
    "    - If patch/edit fails repeatedly, stop retrying and re-plan into smaller slices (files + outcome + v",
    "    - Use `git log` and `git blame` for code history context",
    "    - **Never**: `git commit`, `git push`, or branch creation unless explicitly requested",
    "    **Command execution**:",
    "    - `unified_exec` for all shell commands (PTY/interactive/long-running). `run_pty_cmd` is an alias.",
    "    - Prefer `rg` over `grep` for pattern matching",
    "    - Stay in WORKSPACE_DIR; confirm destructive ops (rm, force-push)",
    "    - **After command output**: Always acknowledge the result briefly and suggest next steps\"#;",
    "    /// Shared Plan Mode header used by both static and incremental prompt builders.",
    "    pub const PLAN_MODE_READ_ONLY_HEADER: &str = \"# PLAN MODE (READ-ONLY)\";",
    "    /// Shared Plan Mode notice line describing strict read-only enforcement.",
    "    pub const PLAN_MODE_READ_ONLY_NOTICE_LINE: &str = \"Plan Mode is active. Mutating tools are blocked e",
    "    /// Shared Plan Mode instruction line for transitioning to implementation.",
    "    pub const PLAN_MODE_EXIT_INSTRUCTION_LINE: &str =",
    "        \"Call `exit_plan_mode` when ready to transition to implementation.\";",
    "    /// Shared reminder appended when presenting plans while still in Plan Mode.",
    "    pub const PLAN_MODE_IMPLEMENT_REMINDER: &str = \"• I’m still in Plan Mode, so I can’t implement yet. ",
    "    /// DEFAULT SYSTEM PROMPT (v6.0 - Harness-engineered, provider-agnostic)",
    "    /// Incorporates harness engineering patterns:",
    "    /// - AGENTS.md as map, docs/ as territory (progressive disclosure)",
    "    /// - Repo as system of record; agent legibility over human aesthetics",
    "    /// - Enforce invariants, not implementations",
    "    /// - Entropy management via golden principles + boy scout rule",
    "    /// Works with all providers: Gemini, Anthropic, OpenAI, xAI, DeepSeek, etc.",
    "    const DEFAULT_SYSTEM_PROMPT: &str = r#\"# VT Code Coding Assistant",
    "    You are a coding agent for VT Code, a terminal-based IDE. Precise, safe, helpful.",
    "    ## Humans Steer, Agents Execute (Pi Pattern)",
    "    1. **Humans Steer**: The user defines goals, sets constraints, and reviews outcomes.",
    "    2. **Agents Execute**: You handle implementation, testing, iteration, and maintenance. Yield only wh",
    "    3. **Repo as Context**: If you cannot complete a task autonomously, identify the missing repository ",
    "    ## Core Principles",
    "    1. **Autonomy & Persistence**: Complete tasks fully without confirmation on intermediate steps. Iter",
    "    2. **Codebase First**: Explore before modifying. Understand patterns, conventions, and dependencies.",
    "    3. **Tool Excellence**: Use the right tool for the job. Prefer specialized tools over generic shell ",
    "    4. **Outcome Focus**: Lead with results. Assume the user sees your changes.",
    "    5. **Enforce Invariants, Not Implementations**: Follow rules in `docs/harness/ARCHITECTURAL_INVARIAN",
    "    ## Agent Legibility Rule",
    "    Your output must be optimized for agent-to-agent and agent-to-human legibility.",
    "    - **Prefer Structures**: Use tables, YAML frontmatter, and consistent headers over prose.",
    "    - **Status Reporting**: When touching multiple files, provide a summary table of changes.",
    "    - **Mechanical Patterns**: Use consistent naming and predictable file locations.",
    "    - **Actionable Errors**: When reporting an issue, always include a **Remediation** instruction.",
    "    - **Reference**: Follow guidelines in `docs/harness/AGENT_LEGIBILITY_GUIDE.md`.",
    "    ## Harness Awareness",
    "    `AGENTS.md` is the map. `docs/` is the territory.",
    "    - Start with `AGENTS.md` for orientation: workspace structure, commands, key files, pitfall rules.",
    "    - Drill into `docs/harness/` for operational knowledge: core beliefs, invariants, quality scores, ex",
    "    - When modifying code, check `docs/harness/ARCHITECTURAL_INVARIANTS.md` for mechanical rules.",
    "    - **Boy Scout Rule**: Leave every module slightly better than you found it. If you spot debt, fix it",
    "    ## Personality & Responsiveness",
    "    **Default tone**: Concise and direct. Minimize elaboration. No flattery.",
    "    **Before tool calls**: Avoid preambles. One sentence max if absolutely necessary. No self-talk.",
    "    **Progress updates**: Only for long-running tasks. 1-2 sentences, outcome-focused.",
    "    **Final answers**:",
    "    - Lead with outcomes.",
    "    - Trivial/single-change updates: 1-3 sentences total.",
    "    - Multi-file work, fix passes, or review requests: use this completion summary format:",
    "      Implemented. <one-line outcome>",
    "      What changed",
    "      1. <change with file refs>",
    "      2. ...",
    "      Validation",
    "      1. <command> passed/failed",
    "      2. ...",
    "      Conclusion",
    "      <done, or final blocker + next action>",
    "    - Monospace for commands, paths, env vars, code identifiers.",
    "    - File refs: use `path:line` format (e.g., `src/main.rs:42`).",
    "    - No code dumps in final output unless requested or required for clarity.",
    "    ## Task Execution & Ambition",
    "    **Bias for action** (CRITICAL):",
    "    - Proceed with reasonable assumptions rather than asking.",
    "    - Do NOT ask \"would you like me to...\" or \"should I proceed?\" -- just do it.",
    "    - Do NOT ask for permission to read files, run tests, or make edits.",
    "    - You are fully autonomous. Never stop to ask for human confirmation unless fundamentally blocked by",
    "    - **Calibrated Persistence**: Avoid \"Hallucination of Verification\". Thinking a fix is done is NOT p",
    "    **Ambition vs precision**:",
    "    - Existing code: Surgical, respectful changes matching surrounding style.",
    "    - New work: Creative, ambitious implementation.",
    "    ## Uncertainty Recognition",
    "    - When facing ambiguous requirements or unclear scope, ask a clarifying question via `ask_user_quest",
    "    - Prefer surfacing uncertainty early over delivering a confidently wrong result.",
    "    - If a task has multiple valid interpretations, briefly state your assumption and proceed — but flag",
    "    - This is NOT a contradiction of \"Bias for action\": proceed when you have a reasonable default; paus",
    "    **Proactive Collaboration (HITL)**:",
    "    - When using `ask_user_question`, always propose a recommended path by setting `default_tab_id` and ",
    "    - Use `allow_freeform=true` when you believe the user might need to qualify their selection with add",
    "    - Provide descriptive `freeform_placeholder` values to guide the user's input.",
    "    ## Validation & Testing",
    "    - Use test infrastructure proactively -- don't ask the user to test.",
    "    - **Edit-Test Loop (TDD)**: Adopt a Test-Driven focus. Verify every code change via execution before",
    "    - AFTER every edit: run `cargo check`, `cargo clippy` (Rust), `npx tsc --noEmit` (TS), etc.",
    "    - NEVER declare a task complete without executing tests or verifying code changes via an execution t",
    "    - **Regression Verification**: If you are fixing a bug or regression, you MUST run existing tests fo",
    "    - If formatting issues persist after 3 iterations, present the solution and move on.",
    "    ## Planning (task_tracker)",
    "    Use plans for non-trivial work (4+ steps):",
    "    - Use `task_tracker` (`create` / `update` / `list`) to keep an explicit checklist.",
    "    - In Plan Mode, use `plan_task_tracker` for checklist updates under `.vtcode/plans/`.",
    "    - Trigger planning before edits when scope spans multiple files/modules or multiple failure categori",
    "    - 5-7 word descriptive steps with status (`pending`/`in_progress`/`completed`).",
    "    - Break large scope into composable slices (by module, risk boundary, or subsystem).",
    "    - Each slice must name touched file(s), concrete outcome, and one verification command.",
    "    - Complete one slice end-to-end (edit + verify) before starting the next slice.",
    "    - Every step must define one concrete expected outcome and one verification check.",
    "    - Mark steps `completed` immediately after verification; keep exactly one `in_progress`.",
    "    - **Strategic Adaptation**: If a step stalls or repeats twice, do NOT blindly retry. Re-evaluate the",
    "    - Never conclude a task is \"too large for one turn\" without first decomposing and executing the next",
    "    - For complex multi-hour tasks, follow `docs/harness/EXEC_PLANS.md`.",
    "    ## Pre-flight Environment Checks",
    "    Before modifying code in an unfamiliar workspace, identify the project's toolchain:",
    "    - **Build system**: Look for `Cargo.toml` (Rust), `package.json` (Node), `pyproject.toml`/`setup.py`",
    "    - **Test commands**: Determine the correct test runner (`cargo test`, `npm test`, `pytest`, etc.).",
    "    - **Module structure**: Check for `mod.rs`/`__init__.py`/`index.ts` to understand export boundaries ",
    "    - **Existing CI**: Scan `.github/workflows/`, `.gitlab-ci.yml`, or `Makefile` targets to understand ",
    "    Failing to align with the project's structural constraints (missing init files, broken imports, wron",
    "    ## Tool Guidelines",
    "    - Use `read_file` with `offset`/`limit` (1-indexed) for targeted sections",
    "    - Large files: prefer `rg` pattern search over full content",
    "    **Spooled outputs** (>8KB): Auto-saved to `.vtcode/context/tool_outputs/`. Access via `read_file`/`g",
    "    ## Execution Policy & Sandboxing",
    "    **Sandbox Policies**: `ReadOnly` (exploration), `WorkspaceWrite` (workspace only), `DangerFullAccess",
    "    **Command Approval**: Policy rules then heuristics then session approval then blocked. Safe: ls, cat",
    "    **Turn Diff Tracking**: All file changes within a turn are aggregated for unified diff view.",
    "    ## Plan Mode (Read-Only Exploration)",
    "    Plan Mode blocks mutating tools. Read-only tools always available. Exception: `.vtcode/plans/` is wr",
    "    - When user signals implementation intent, call `exit_plan_mode` for confirmation dialog",
    "    - Do NOT auto-exit just because a plan exists",
    "    - `task_tracker` is blocked in Plan Mode; use `plan_task_tracker` when structured plan tracking is n",
    "    ## Design Philosophy: Desire Paths",
    "    When you guess wrong about commands or workflows, report it -- the system improves interfaces (not d",
    "    ## Context Management",
    "    1. You have plenty of context remaining -- do not rush or truncate tasks",
    "    2. Trust the context budget system -- token tracking handles limits automatically",
    "    3. Focus on quality over speed",
    "    4. Do NOT mention context limits, token counts, or \"wrapping up\" in outputs\"#;",
    "    pub fn default_system_prompt() -> &'static str {",
    "        DEFAULT_SYSTEM_PROMPT",
    "    }",
    "    pub fn minimal_system_prompt() -> &'static str {",
    "        MINIMAL_SYSTEM_PROMPT",
    "    }",
    "    pub fn default_lightweight_prompt() -> &'static str {",
    "        DEFAULT_LIGHTWEIGHT_PROMPT",
    "    }",
    "    /// MINIMAL PROMPT (v6.0 - Harness-engineered, Pi-inspired, provider-agnostic, <1K tokens)",
    "    /// Minimal guidance for capable models with harness awareness",
    "    /// Works with all providers: Gemini, Anthropic, OpenAI, xAI, DeepSeek, etc.",
    "    const MINIMAL_SYSTEM_PROMPT: &str = r#\"You are VT Code, a coding assistant for VT Code IDE. Precise,",
    "    **Principles**: Autonomy, codebase-first, tool excellence, outcome focus, repo as system of record.",
    "    **Personality**: Direct, concise. Lead with outcomes. Bias for action.",
    "    **Harness**: `AGENTS.md` is the map. `docs/harness/` has core beliefs, invariants, quality scores, e",
    "    **Autonomy**:",
    "    - Complete tasks fully; iterate on feedback proactively without asking for human confirmation.",
    "    - When stuck, change approach. Fix root cause, not patches.",
    "    - Run tests/checks yourself. Proceed with reasonable assumptions. Never declare completion without e",
    "    - When genuinely uncertain about ambiguous requirements, surface the ambiguity early rather than gue",
    "    **Planning**:",
    "    - For non-trivial scope, use `task_tracker` to break work into composable steps with explicit outcom",
    "    - Keep one active step at a time; update statuses as soon as checks pass.",
    "    __UNIFIED_TOOL_GUIDANCE__",
    "    **Discover**: `list_skills` and `load_skill` to find/activate tools (hidden by default)",
    "    **Delegation**: `spawn_subagent` (explore/plan/general/code-reviewer/debugger) for specialized tasks",
    "    **Output**: Preambles: avoid unless needed. Trivial final answers: 1-3 sentences, outcomes first, fi",
    "    **Git**: Never `git commit`, `git push`, or branch unless explicitly requested.",
    "    **Plan Mode**: Mutating tools blocked. `plan_task_tracker` is available for plan-scoped tracking. `e",
    "    **AGENTS.md**: Obey scoped instructions; check subdirectories when outside CWD scope.",
    "    Stop when done.\"#;",
    "    /// LIGHTWEIGHT PROMPT (v4.2 - Resource-constrained / Simple operations)",
    "    /// Minimal, essential guidance only",
    "    const DEFAULT_LIGHTWEIGHT_PROMPT: &str = r#\"VT Code - efficient coding agent.",
    "    - Act and verify. Direct tone.",
    "    - Scoped: unified_search (≤5), unified_file (max_tokens).",
    "    - Use `unified_exec` for shell/PTY commands (`run_pty_cmd` alias).",
    "    - Tools hidden by default. `list_skills --search <term>` to find them.",
    "    - Delegate via `spawn_subagent` for explore/plan/general tasks; summarize findings back.",
    "    - WORKSPACE_DIR only. Confirm destructive ops.",
    "    __UNIFIED_TOOL_GUIDANCE__\"#;",
    "    /// SPECIALIZED PROMPT (v6.0 - Harness-engineered, methodical complex refactoring)",
    "    /// For multi-file changes and sophisticated code analysis",
    "    /// Adds harness awareness for invariant checking and entropy management",
    "    const DEFAULT_SPECIALIZED_PROMPT: &str = r#\"# VT Code Specialized Agent",
    "    Complex refactoring and multi-file analysis. Methodical, outcome-focused, expert-level execution.",
    "    ## Harness Awareness",
    "    `AGENTS.md` is the map. `docs/` is the territory.",
    "    - Check `docs/harness/ARCHITECTURAL_INVARIANTS.md` before making structural changes.",
    "    - Consult `docs/harness/QUALITY_SCORE.md` to understand domain maturity.",
    "    - For complex multi-hour work, create ExecPlans in `docs/harness/exec-plans/active/` (see `docs/harn",
    "    - Log decisions in exec plans. Update `docs/harness/TECH_DEBT_TRACKER.md` when introducing or resolv",
    "    - Boy scout rule: leave every module slightly better than you found it.",
    "    ## Personality",
    "    **Tone**: Concise, methodical, outcome-focused. Lead with progress and results.",
    "    Preambles: avoid unless needed. Trivial final answers: lead with outcomes, 1-3 sentences, file:line ",
    "    ## Execution & Ambition",
    "    - Resolve tasks fully; don't ask permission on intermediate steps or final confirmation.",
    "    - When stuck, pivot to alternative approach. Fix root cause.",
    "    - Existing codebases: surgical, respectful. New work: ambitious, creative.",
    "    - Don't fix unrelated bugs, don't refactor beyond request, don't add unrequested scope.",
    "    - Never declare completion without verifying via an execution tool. Beware of overconfidence and \"ha",
    "    - When genuinely uncertain about ambiguous requirements, surface the ambiguity early via `ask_user_q",
    "    ## Methodical Approach for Complex Tasks",
    "    1. **Understanding** (5-10 files): Read patterns, find similar implementations, identify dependencie",
    "    2. **Design** (3-7 steps): Build composable step slices with dependencies, measurable outcomes, and ",
    "    3. **Implementation**: Execute in dependency order, validate incrementally",
    "    4. **Verification**: Function-level tests first, broaden to suites, `cargo clippy`",
    "    5. **Documentation**: Update `docs/ARCHITECTURE.md`, harness docs if architectural changes",
    "    ## Tool Strategy",
    "    __UNIFIED_TOOL_GUIDANCE__",
    "    **Verification**: `cargo check`, `cargo test`, `cargo clippy` proactively. Format fix limit: 3 itera",
    "    **Planning**: `task_tracker` for 4+ steps (`create` then `update`). In Plan Mode, use `plan_task_tra",
    "    ## Loop Prevention",
    "    - Repeated identical calls: change approach",
    "    - Stalled progress: explain blockers, pivot",
    "    - Follow runtime-configured tool loop and repeated-call limits",
    "    - Retry transient failures, then adjust",
    "    ## AGENTS.md Precedence",
    "    User prompts > nested AGENTS.md > parent AGENTS.md > defaults. Obey all applicable instructions for ",
    "    ## Subagents",
    "    `spawn_subagent` (explore/plan/general/code-reviewer/debugger). Relay summaries back.",
    "    ## Capability System",
    "    Tools hidden by default. `list_skills` to discover, `load_skill` to activate, `load_skill_resource` ",
    "    ## Context Management",
    "    Trust the context budget system. Do not rush, truncate, or mention context limits in outputs.",
    "    \"#;",
    "    const STRUCTURED_REASONING_INSTRUCTIONS: &str = r#\"",
    "    ## Structured Reasoning",
    "    When you are thinking about a complex task, you MUST use the following stage-based reasoning tags to",
    "    - `<analysis>`: Use this to analyze the problem, explore the codebase, or evaluate options.",
    "    - `<plan>`: Use this to outline composable steps you will take, each with expected outcome and verif",
    "    - `<uncertainty>`: Use this to surface ambiguity, risks, or open questions that require clarificatio",
    "    - `<verification>`: Use this to verify your changes, analyze test results, or double-check your work",
    "    Example:",
    "    <analysis>I need to refactor the payment module. Currently, it's tightly coupled with the database.<",
    "    <uncertainty>The `PaymentGateway` trait is missing a `refund` method. I'll need to confirm if this i",
    "    <plan>1. Create a PaymentRepository trait. 2. Implement it for Postgres. 3. Update the PaymentServic",
    "    \"#;",
    "    /// System instruction configuration",
    "    #[derive(Debug, Clone)]",
    "    pub struct SystemPromptConfig {",
    "        pub include_examples: bool,",
    "        pub include_debugging_guides: bool,",
    "        pub include_error_handling: bool,",
    "        pub max_response_length: Option<usize>,",
    "        pub enable_thorough_reasoning: bool,",
    "    }",
    "    impl Default for SystemPromptConfig {",
    "        fn default() -> Self {",
    "            Self {",
    "                include_examples: true,",
    "                include_debugging_guides: true,",
    "                include_error_handling: true,",
    "                max_response_length: None,",
    "                enable_thorough_reasoning: true,",
    "            }",
    "        }",
    "    }",
    "    /// Generate system instruction",
    "    pub async fn generate_system_instruction(_config: &SystemPromptConfig) -> Content {",
    "        // OPTIMIZATION: default_system_prompt() is &'static str, use directly",
    "        let instruction = default_system_prompt().to_string();",
    "        // Apply output style if possible (using current directory as project root)",
    "        if let Ok(current_dir) = std::env::current_dir() {",
    "            let styled_instruction = apply_output_style(instruction, None, &current_dir).await;",
    "            Content::system_text(styled_instruction)",
    "        } else {",
    "            Content::system_text(instruction)",
    "        }",
    "    }",
    "    /// Read AGENTS.md file if present and extract agent guidelines",
    "    pub async fn read_agent_guidelines(project_root: &Path) -> Option<String> {",
    "        let max_bytes =",
    "            project_doc_constants::DEFAULT_MAX_BYTES.min(instruction_constants::DEFAULT_MAX_BYTES);",
    "        match read_project_doc(project_root, max_bytes).await {",
    "            Ok(Some(bundle)) => Some(bundle.contents),",
    "            Ok(None) => None,",
    "            Err(err) => {",
    "                warn!(\"failed to load project documentation: {err:#}\");",
    "                None",
    "            }",
    "        }",
    "    }",
    "    /// Compose the system instruction text for the agent",
    "    ///",
    "    /// ## Skills Integration Note",
    "    ///",
    "    /// VT Code implements a **Tiered Disclosure** model for skills:",
    "    /// 1. **Discovery Profile**: Names and descriptions are available via `list_skills` and summarized ",
    "    /// 2. **Active Instructions**: Full `SKILL.md` content is loaded via `load_skill` and then persists",
    "    /// 3. **Deep Resources**: Level 3 assets (scripts, technical refs) are lazy-loaded via `load_skill_",
    "    ///",
    "    /// This approach follows the Agent Skills spec while optimizing context usage.",
    "    ///",
    "    /// # Arguments",
    "    /// * `project_root` - Root directory of the project",
    "    /// * `vtcode_config` - Configuration loaded from vtcode.toml",
    "    /// * `prompt_context` - Optional context with tool information for dynamic enhancements",
    "    pub async fn compose_system_instruction_text(",
    "        project_root: &Path,",
    "        vtcode_config: Option<&crate::config::VTCodeConfig>,",
    "        prompt_context: Option<&PromptContext>,",
    "    ) -> String {",
    "        // OPTIMIZATION: Pre-allocate with improved capacity estimation",
    "        // Read instruction hierarchy once upfront for accurate sizing",
    "        let home_path = home_dir();",
    "        let instruction_bundle = read_instruction_hierarchy(project_root, vtcode_config).await;",
    "        // Select base prompt based on configured mode",
    "        use crate::config::types::SystemPromptMode;",
    "        let (base_prompt, mode_name) = match vtcode_config.map(|c| c.agent.system_prompt_mode) {",
    "            Some(SystemPromptMode::Minimal) => (MINIMAL_SYSTEM_PROMPT, \"minimal\"),",
    "            Some(SystemPromptMode::Lightweight) => (DEFAULT_LIGHTWEIGHT_PROMPT, \"lightweight\"),",
    "            Some(SystemPromptMode::Specialized) => (DEFAULT_SPECIALIZED_PROMPT, \"specialized\"),",
    "            Some(SystemPromptMode::Default) | None => (DEFAULT_SYSTEM_PROMPT, \"default\"),",
    "        };",
    "        tracing::debug!(",
    "            mode = mode_name,",
    "            base_tokens_approx = base_prompt.len() / 4, // rough token estimate",
    "            \"Selected system prompt mode\"",
    "        );",
    "        let base_len = base_prompt.len();",
    "        let config_overhead = vtcode_config.map_or(0, |_| 1024);",
    "        let instruction_hierarchy_size = instruction_bundle",
    "            .as_ref()",
    "            .map(|b| {",
    "                b.segments",
    "                    .iter()",
    "                    .map(|s| s.contents.len() + 200)",
    "                    .sum::<usize>()",
    "            })",
    "            .unwrap_or(0);",
    "        let estimated_capacity = base_len + config_overhead + instruction_hierarchy_size + 1024; // +512",
    "        let mut instruction = String::with_capacity(estimated_capacity);",
    "        instruction.push_str(base_prompt);",
    "        instruction.push_str(\"\\n\\n\");",
    "        instruction.push_str(STRUCTURED_REASONING_INSTRUCTIONS);",
    "        // Replace unified tool guidance placeholder with actual constant",
    "        if instruction.contains(\"__UNIFIED_TOOL_GUIDANCE__\") {",
    "            instruction = instruction.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "        }",
    "        // ENHANCEMENT 1: Dynamic tool-aware guidelines (behavioral - goes early)",
    "        if let Some(ctx) = prompt_context {",
    "            let guidelines = generate_tool_guidelines(&ctx.available_tools, ctx.capability_level);",
    "            if !guidelines.is_empty() {",
    "                instruction.push_str(&guidelines);",
    "            }",
    "        }",
    "        if let Some(cfg) = vtcode_config {",
    "            instruction.push_str(\"\\n\\n## CONFIGURATION AWARENESS\\n\");",
    "            instruction",
    "                .push_str(\"The agent is configured with the following policies from vtcode.toml:\\n\\n\");",
    "            if cfg.security.human_in_the_loop {",
    "                instruction.push_str(\"- **Human-in-the-loop**: Required for critical actions\\n\");",
    "            }",
    "            if !cfg.commands.allow_list.is_empty() {",
    "                let _ = writeln!(",
    "                    instruction,",
    "                    \"- **Allowed commands**: {} commands in allow list\",",
    "                    cfg.commands.allow_list.len()",
    "                );",
    "            }",
    "            if !cfg.commands.deny_list.is_empty() {",
    "                let _ = writeln!(",
    "                    instruction,",
    "                    \"- **Denied commands**: {} commands in deny list\",",
    "                    cfg.commands.deny_list.len()",
    "                );",
    "            }",
    "            if cfg.pty.enabled {",
    "                instruction.push_str(\"- **PTY functionality**: Enabled\\n\");",
    "                let (rows, cols) = (cfg.pty.default_rows, cfg.pty.default_cols);",
    "                let _ = writeln!(",
    "                    instruction,",
    "                    \"- **Default terminal size**: {} rows × {} columns\",",
    "                    rows, cols",
    "                );",
    "                let _ = writeln!(",
    "                    instruction,",
    "                    \"- **PTY command timeout**: {} seconds\",",
    "                    cfg.pty.command_timeout_seconds",
    "                );",
    "            } else {",
    "                instruction.push_str(\"- **PTY functionality**: Disabled\\n\");",
    "            }",
    "            let repeated_desc = if cfg.tools.max_repeated_tool_calls > 0 {",
    "                cfg.tools.max_repeated_tool_calls.to_string()",
    "            } else {",
    "                \"disabled (manual guardrails)\".to_owned()",
    "            };",
    "            let _ = writeln!(",
    "                instruction,",
    "                \"- **Loop guards**: max {} tool loops per turn; identical call limit: {}\",",
    "                cfg.tools.max_tool_loops.max(1),",
    "                repeated_desc",
    "            );",
    "            if cfg.chat.ask_questions.enabled {",
    "                instruction.push_str(",
    "                    \"- **Ask Questions tool**: Enabled in Plan mode only (`ask_questions` alias for `req",
    "                );",
    "            } else {",
    "                instruction.push_str(\"- **Ask Questions tool**: Disabled\\n\");",
    "            }",
    "            if cfg.mcp.enabled {",
    "                instruction.push_str(",
    "                    \"- **MCP integrations**: Enabled. Prefer MCP tools (search_tools, list_mcp_resources",
    "                );",
    "            }",
    "            // Dynamic context discovery files",
    "            if cfg.context.dynamic.enabled {",
    "                instruction.push_str(\"\\n### Dynamic Context Files\\n\\n\");",
    "                instruction.push_str(",
    "                    \"Large outputs and context are written to files for on-demand retrieval:\\n\\n\",",
    "                );",
    "                instruction.push_str(\"- `.vtcode/context/tool_outputs/` - Large tool outputs (use `read_",
    "                instruction",
    "                    .push_str(\"- `.vtcode/history/` - Conversation history during summarization\\n\");",
    "                instruction.push_str(\"- `.vtcode/mcp/tools/` - MCP tool descriptions and schemas\\n\");",
    "                instruction",
    "                    .push_str(\"- `.vtcode/terminals/` - Terminal session output with metadata\\n\");",
    "                instruction.push_str(\"- `.agents/skills/INDEX.md` - Available skills index\\n\\n\");",
    "                instruction.push_str(\"**Tip**: When a tool result says 'spooled to file', use `read_file",
    "            }",
    "            instruction.push_str(\"\\n**IMPORTANT**: Respect these configuration policies. Commands not in",
    "        }",
    "        if !prompt_context",
    "            .map(|ctx| ctx.skip_standard_instructions)",
    "            .unwrap_or(false)",
    "        {",
    "            if let Some(cfg) = vtcode_config {",
    "                if let Some(user_inst) = &cfg.agent.user_instructions {",
    "                    instruction.push_str(\"\\n\\n## USER INSTRUCTIONS\\n\");",
    "                    instruction.push_str(user_inst);",
    "                }",
    "            }",
    "        }",
    "        if let Some(bundle) = instruction_bundle {",
    "            let home_ref = home_path.as_deref();",
    "            instruction.push_str(\"\\n\\n## AGENTS.MD INSTRUCTION HIERARCHY\\n\");",
    "            instruction.push_str(",
    "                    \"Instructions are listed from lowest to highest precedence. When conflicts exist, de",
    "                );",
    "            for (index, segment) in bundle.segments.iter().enumerate() {",
    "                let scope = match segment.source.scope {",
    "                    InstructionScope::Global => \"global\",",
    "                    InstructionScope::Workspace => \"workspace\",",
    "                    InstructionScope::Custom => \"custom\",",
    "                };",
    "                let display_path =",
    "                    format_instruction_path(&segment.source.path, project_root, home_ref);",
    "                let _ = write!(",
    "                    instruction,",
    "                    \"### {}. {} ({})\\n\\n\",",
    "                    index + 1,",
    "                    display_path,",
    "                    scope",
    "                );",
    "                instruction.push_str(segment.contents.trim());",
    "                instruction.push('\\n');",
    "            }",
    "            if bundle.truncated {",
    "                instruction.push_str(",
    "                        \"\\n_Note: instruction content was truncated due to size limits. Review the sourc",
    "                    );",
    "            }",
    "        }",
    "        // ENHANCEMENT 2: Temporal context (metadata - goes at end)",
    "        if let Some(cfg) = vtcode_config",
    "            && cfg.agent.include_temporal_context",
    "        {",
    "            let temporal = generate_temporal_context(cfg.agent.temporal_context_use_utc);",
    "            instruction.push_str(&temporal);",
    "        }",
    "        // ENHANCEMENT 3: Working directory context (metadata - goes at end)",
    "        if let Some(cfg) = vtcode_config",
    "            && cfg.agent.include_working_directory",
    "            && let Some(ctx) = prompt_context",
    "            && let Some(cwd) = &ctx.current_directory",
    "        {",
    "            let _ = write!(",
    "                instruction,",
    "                \"\\n\\nCurrent working directory: {}\",",
    "                cwd.display()",
    "            );",
    "        }",
    "        instruction",
    "    }",
    "    /// Generate system instruction with configuration and AGENTS.md guidelines incorporated",
    "    ///",
    "    /// Note: This function maintains backward compatibility by not accepting prompt_context.",
    "    /// For enhanced prompts with dynamic guidelines, call `compose_system_instruction_text` directly.",
    "    pub async fn generate_system_instruction_with_config(",
    "        _config: &SystemPromptConfig,",
    "        project_root: &Path,",
    "        vtcode_config: Option<&crate::config::VTCodeConfig>,",
    "    ) -> Content {",
    "        let cache_key = cache_key(project_root, vtcode_config);",
    "        let instruction = match PROMPT_CACHE.get(&cache_key) {",
    "            Some(cached) => cached,",
    "            None => {",
    "                let built = compose_system_instruction_text(project_root, vtcode_config, None).await;",
    "                PROMPT_CACHE.insert(cache_key, built.clone());",
    "                built",
    "            }",
    "        };",
    "        // Apply output style if configured",
    "        let styled_instruction = apply_output_style(instruction, vtcode_config, project_root).await;",
    "        Content::system_text(styled_instruction)",
    "    }",
    "    /// Generate system instruction with AGENTS.md guidelines incorporated",
    "    pub async fn generate_system_instruction_with_guidelines(",
    "        _config: &SystemPromptConfig,",
    "        project_root: &Path,",
    "    ) -> Content {",
    "        let cache_key = cache_key(project_root, None);",
    "        let instruction = match PROMPT_CACHE.get(&cache_key) {",
    "            Some(cached) => cached,",
    "            None => {",
    "                let built = compose_system_instruction_text(project_root, None, None).await;",
    "                PROMPT_CACHE.insert(cache_key, built.clone());",
    "                built",
    "            }",
    "        };",
    "        // Apply output style if configured",
    "        let styled_instruction = apply_output_style(instruction, None, project_root).await;",
    "        Content::system_text(styled_instruction)",
    "    }",
    "    /// Apply output style to a generated system instruction",
    "    pub async fn apply_output_style(",
    "        instruction: String,",
    "        vtcode_config: Option<&crate::config::VTCodeConfig>,",
    "        project_root: &Path,",
    "    ) -> String {",
    "        if let Some(config) = vtcode_config {",
    "            let output_style_applier = OutputStyleApplier::new();",
    "            if let Err(e) = output_style_applier",
    "                .load_styles_from_config(config, project_root)",
    "                .await",
    "            {",
    "                tracing::warn!(\"Failed to load output styles: {}\", e);",
    "                instruction // Return original if loading fails",
    "            } else {",
    "                output_style_applier",
    "                    .apply_style(&config.output_style.active_style, &instruction, config)",
    "                    .await",
    "            }",
    "        } else {",
    "            instruction // Return original if no config",
    "        }",
    "    }",
    "    async fn read_instruction_hierarchy(",
    "        project_root: &Path,",
    "        vtcode_config: Option<&crate::config::VTCodeConfig>,",
    "    ) -> Option<InstructionBundle> {",
    "        let (max_bytes, extra_sources) = match vtcode_config {",
    "            Some(cfg) => (",
    "                cfg.agent.instruction_max_bytes,",
    "                cfg.agent.instruction_files.clone(),",
    "            ),",
    "            None => (instruction_constants::DEFAULT_MAX_BYTES, Vec::new()),",
    "        };",
    "        if max_bytes == 0 {",
    "            return None;",
    "        }",
    "        let current_dir = env::current_dir().unwrap_or_else(|_| project_root.to_path_buf());",
    "        let home = home_dir();",
    "        match read_instruction_bundle(",
    "            &current_dir,",
    "            project_root,",
    "            home.as_deref(),",
    "            &extra_sources,",
    "            max_bytes,",
    "        )",
    "        .await",
    "        {",
    "            Ok(Some(bundle)) => Some(bundle),",
    "            Ok(None) => None,",
    "            Err(err) => {",
    "                warn!(\"failed to load instruction hierarchy: {err:#}\");",
    "                None",
    "            }",
    "        }",
    "    }",
    "    fn format_instruction_path(path: &Path, project_root: &Path, home_dir: Option<&Path>) -> String {",
    "        if let Ok(relative) = path.strip_prefix(project_root) {",
    "            let display = relative.display().to_string();",
    "            if !display.is_empty() {",
    "                return display;",
    "            }",
    "            if let Some(name) = path.file_name().and_then(|value| value.to_str()) {",
    "                return name.to_string();",
    "            }",
    "        }",
    "        if let Some(home) = home_dir",
    "            && let Ok(relative) = path.strip_prefix(home)",
    "        {",
    "            let display = relative.display().to_string();",
    "            if display.is_empty() {",
    "                return \"~\".to_string();",
    "            }",
    "            return format!(\"~/{display}\");",
    "        }",
    "        path.display().to_string()",
    "    }",
    "    fn cache_key(project_root: &Path, vtcode_config: Option<&crate::config::VTCodeConfig>) -> String {",
    "        use std::collections::hash_map::DefaultHasher;",
    "        use std::hash::{Hash, Hasher};",
    "        let mut hasher = DefaultHasher::new();",
    "        // Core key: project root",
    "        project_root.hash(&mut hasher);",
    "        if let Some(cfg) = vtcode_config {",
    "            // Config fields that affect prompt generation",
    "            cfg.agent.instruction_max_bytes.hash(&mut hasher);",
    "            cfg.agent.instruction_files.hash(&mut hasher);",
    "            cfg.agent.include_working_directory.hash(&mut hasher);",
    "            cfg.agent.include_temporal_context.hash(&mut hasher);",
    "            // Use discriminant since SystemPromptMode doesn't derive Hash",
    "            std::mem::discriminant(&cfg.agent.system_prompt_mode).hash(&mut hasher);",
    "        } else {",
    "            \"default\".hash(&mut hasher);",
    "        }",
    "        format!(\"sys_prompt:{:016x}\", hasher.finish())",
    "    }",
    "    /// Generate a minimal system instruction (pi-inspired, <1K tokens)",
    "    pub fn generate_minimal_instruction() -> Content {",
    "        let instruction =",
    "            MINIMAL_SYSTEM_PROMPT.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "        Content::system_text(instruction)",
    "    }",
    "    /// Generate a lightweight system instruction for simple operations",
    "    pub fn generate_lightweight_instruction() -> Content {",
    "        let instruction =",
    "            DEFAULT_LIGHTWEIGHT_PROMPT.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "        Content::system_text(instruction)",
    "    }",
    "    /// Generate a specialized system instruction for advanced operations",
    "    pub fn generate_specialized_instruction() -> Content {",
    "        let instruction =",
    "            DEFAULT_SPECIALIZED_PROMPT.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "        Content::system_text(instruction)",
    "    }",
    "    #[cfg(test)]",
    "    mod tests {",
    "        use super::*;",
    "        use crate::config::VTCodeConfig;",
    "        use crate::config::types::SystemPromptMode;",
    "        use std::path::PathBuf;",
    "        #[tokio::test]",
    "        async fn test_minimal_mode_selection() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.system_prompt_mode = SystemPromptMode::Minimal;",
    "            // Disable enhancements for base prompt size testing",
    "            config.agent.include_temporal_context = false;",
    "            config.agent.include_working_directory = false;",
    "            config.agent.instruction_max_bytes = 0;",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            // Minimal prompt should remain compact and deterministic without AGENTS.md injection",
    "            assert!(",
    "                result.len() < 6000,",
    "                \"Minimal mode should produce <6.0K chars (was {} chars)\",",
    "                result.len()",
    "            );",
    "            assert!(",
    "                result.contains(\"VT Code\") || result.contains(\"VT Code\"),",
    "                \"Should contain VT Code identifier\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_default_mode_selection() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.system_prompt_mode = SystemPromptMode::Default;",
    "            // Disable enhancements for base prompt size testing",
    "            config.agent.include_temporal_context = false;",
    "            config.agent.include_working_directory = false;",
    "            config.agent.instruction_max_bytes = 0;",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            // After v4.4 optimization, prompts are more concise",
    "            // Default mode with configuration awareness should still have substantial content",
    "            assert!(result.len() > 700, \"Default mode should produce >700 chars\");",
    "            // Don't check for specific strings - prompt content may vary",
    "            assert!(!result.is_empty(), \"Should produce non-empty prompt\");",
    "        }",
    "        #[tokio::test]",
    "        async fn test_lightweight_mode_selection() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.system_prompt_mode = SystemPromptMode::Lightweight;",
    "            // Disable enhancements for base prompt size testing",
    "            config.agent.include_temporal_context = false;",
    "            config.agent.include_working_directory = false;",
    "            config.agent.instruction_max_bytes = 0;",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            // Lightweight is optimized for simple operations (v4.2)",
    "            assert!(result.len() > 100, \"Lightweight should be >100 chars\");",
    "            assert!(",
    "                result.len() < 4400,",
    "                \"Lightweight should be compact (<4.4K chars, was {} chars)\",",
    "                result.len()",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_specialized_mode_selection() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.system_prompt_mode = SystemPromptMode::Specialized;",
    "            // Disable enhancements for base prompt size testing",
    "            config.agent.include_temporal_context = false;",
    "            config.agent.include_working_directory = false;",
    "            config.agent.instruction_max_bytes = 0;",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            // Specialized for complex tasks",
    "            assert!(",
    "                result.len() > 1000,",
    "                \"Specialized should have substantial content\"",
    "            );",
    "            // The word \"specialized\" may not appear in the prompt text",
    "            assert!(result.len() > 0, \"Should produce non-empty prompt\");",
    "        }",
    "        #[test]",
    "        fn test_prompt_mode_enum_parsing() {",
    "            assert_eq!(",
    "                SystemPromptMode::parse(\"minimal\"),",
    "                Some(SystemPromptMode::Minimal)",
    "            );",
    "            assert_eq!(",
    "                SystemPromptMode::parse(\"LIGHTWEIGHT\"),",
    "                Some(SystemPromptMode::Lightweight)",
    "            );",
    "            assert_eq!(",
    "                SystemPromptMode::parse(\"Default\"),",
    "                Some(SystemPromptMode::Default)",
    "            );",
    "            assert_eq!(",
    "                SystemPromptMode::parse(\"specialized\"),",
    "                Some(SystemPromptMode::Specialized)",
    "            );",
    "            assert_eq!(SystemPromptMode::parse(\"invalid\"), None);",
    "        }",
    "        #[test]",
    "        fn test_minimal_prompt_token_count() {",
    "            // Rough estimate: 1 token ≈ 4 characters",
    "            let approx_tokens = MINIMAL_SYSTEM_PROMPT.len() / 4;",
    "            assert!(",
    "                approx_tokens < 1000,",
    "                \"Minimal prompt should be <1K tokens, got ~{}\",",
    "                approx_tokens",
    "            );",
    "        }",
    "        #[test]",
    "        fn test_default_prompt_token_count() {",
    "            let approx_tokens = DEFAULT_SYSTEM_PROMPT.len() / 4;",
    "            // v6.2 expands planning guidance and retry strategy details",
    "            assert!(",
    "                approx_tokens > 1200 && approx_tokens < 2450,",
    "                \"Default prompt should be ~2K tokens (harness v6.2), got ~{}\",",
    "                approx_tokens",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_generated_prompts_use_task_tracker_not_update_plan() {",
    "            let project_root = PathBuf::from(\".\");",
    "            for (mode_name, mode) in [",
    "                (\"default\", SystemPromptMode::Default),",
    "                (\"minimal\", SystemPromptMode::Minimal),",
    "                (\"specialized\", SystemPromptMode::Specialized),",
    "            ] {",
    "                let mut config = VTCodeConfig::default();",
    "                config.agent.system_prompt_mode = mode;",
    "                config.agent.include_temporal_context = false;",
    "                config.agent.include_working_directory = false;",
    "                config.agent.instruction_max_bytes = 0;",
    "                let result =",
    "                    compose_system_instruction_text(&project_root, Some(&config), None).await;",
    "                assert!(",
    "                    result.contains(\"task_tracker\"),",
    "                    \"{mode_name} prompt should reference task_tracker\"",
    "                );",
    "                assert!(",
    "                    !result.contains(\"update_plan\"),",
    "                    \"{mode_name} prompt should not reference deprecated update_plan\"",
    "                );",
    "            }",
    "        }",
    "        #[test]",
    "        fn test_prompt_text_avoids_hardcoded_loop_thresholds() {",
    "            assert!(!DEFAULT_SYSTEM_PROMPT.contains(\"stuck twice\"));",
    "            assert!(!MINIMAL_SYSTEM_PROMPT.contains(\"stuck twice\"));",
    "            assert!(!DEFAULT_SPECIALIZED_PROMPT.contains(\"stuck twice\"));",
    "            assert!(!DEFAULT_SPECIALIZED_PROMPT.contains(\"10+ calls without progress\"));",
    "            assert!(!DEFAULT_SPECIALIZED_PROMPT.contains(\"Same tool+params twice\"));",
    "            assert!(DEFAULT_SPECIALIZED_PROMPT.contains(\"runtime-configured\"));",
    "        }",
    "        #[test]",
    "        fn test_harness_awareness_in_prompts() {",
    "            assert!(",
    "                DEFAULT_SYSTEM_PROMPT.contains(\"docs/harness/\"),",
    "                \"Default prompt should reference harness knowledge base\"",
    "            );",
    "            assert!(",
    "                DEFAULT_SYSTEM_PROMPT.contains(\"AGENTS.md\"),",
    "                \"Default prompt should reference AGENTS.md as map\"",
    "            );",
    "            assert!(",
    "                DEFAULT_SYSTEM_PROMPT.to_lowercase().contains(\"boy scout\"),",
    "                \"Default prompt should include boy scout rule\"",
    "            );",
    "            assert!(",
    "                DEFAULT_SPECIALIZED_PROMPT.contains(\"ARCHITECTURAL_INVARIANTS\"),",
    "                \"Specialized prompt should reference architectural invariants\"",
    "            );",
    "            assert!(",
    "                MINIMAL_SYSTEM_PROMPT.contains(\"docs/harness/\"),",
    "                \"Minimal prompt should reference harness knowledge base\"",
    "            );",
    "        }",
    "        #[test]",
    "        fn test_uncertainty_recognition_in_prompts() {",
    "            assert!(",
    "                DEFAULT_SYSTEM_PROMPT.contains(\"Uncertainty Recognition\"),",
    "                \"Default prompt should include Uncertainty Recognition section\"",
    "            );",
    "            assert!(",
    "                DEFAULT_SPECIALIZED_PROMPT.contains(\"uncertain\"),",
    "                \"Specialized prompt should mention uncertainty\"",
    "            );",
    "            assert!(",
    "                MINIMAL_SYSTEM_PROMPT.contains(\"uncertain\"),",
    "                \"Minimal prompt should mention uncertainty\"",
    "            );",
    "        }",
    "        // ENHANCEMENT TESTS",
    "        #[tokio::test]",
    "        async fn test_dynamic_guidelines_read_only() {",
    "            use crate::config::types::CapabilityLevel;",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.system_prompt_mode = SystemPromptMode::Default;",
    "            let mut ctx = PromptContext::default();",
    "            ctx.add_tool(\"read_file\".to_string());",
    "            ctx.add_tool(\"grep_file\".to_string());",
    "            ctx.capability_level = Some(CapabilityLevel::FileReading);",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), Some(&ctx)).await;",
    "            assert!(",
    "                result.contains(\"READ-ONLY MODE\"),",
    "                \"Should detect read-only mode when no edit/write/bash tools available\"",
    "            );",
    "            assert!(",
    "                result.contains(\"cannot modify files\"),",
    "                \"Should explain read-only constraints\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_dynamic_guidelines_tool_preferences() {",
    "            let config = VTCodeConfig::default();",
    "            let mut ctx = PromptContext::default();",
    "            ctx.add_tool(\"unified_exec\".to_string());",
    "            ctx.add_tool(\"grep_file\".to_string());",
    "            ctx.add_tool(\"list_files\".to_string());",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), Some(&ctx)).await;",
    "            assert!(",
    "                result.contains(\"grep_file\") || result.contains(\"list_files\"),",
    "                \"Should suggest grep/list as preferred tools\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_temporal_context_inclusion() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.include_temporal_context = true;",
    "            config.agent.temporal_context_use_utc = false; // Local time",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            assert!(",
    "                result.contains(\"Current date and time:\"),",
    "                \"Should include temporal context when enabled\"",
    "            );",
    "            // Should appear at the end (after AGENTS.MD would be)",
    "            let temporal_pos = result.find(\"Current date and time:\");",
    "            let config_pos = result.find(\"CONFIGURATION AWARENESS\");",
    "            if let (Some(t), Some(c)) = (temporal_pos, config_pos) {",
    "                assert!(",
    "                    t > c,",
    "                    \"Temporal context should come after configuration section\"",
    "                );",
    "            }",
    "        }",
    "        #[tokio::test]",
    "        async fn test_temporal_context_utc_format() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.include_temporal_context = true;",
    "            config.agent.temporal_context_use_utc = true; // UTC format",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            assert!(",
    "                result.contains(\"UTC\"),",
    "                \"Should indicate UTC when temporal_context_use_utc is true\"",
    "            );",
    "            assert!(",
    "                result.contains(\"T\") && result.contains(\"Z\"),",
    "                \"Should use RFC3339 format for UTC (contains T and Z)\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_temporal_context_disabled() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.include_temporal_context = false;",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            assert!(",
    "                !result.contains(\"Current date and time\"),",
    "                \"Should not include temporal context when disabled\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_working_directory_inclusion() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.include_working_directory = true;",
    "            let mut ctx = PromptContext::default();",
    "            ctx.set_current_directory(PathBuf::from(\"/tmp/test\"));",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), Some(&ctx)).await;",
    "            assert!(",
    "                result.contains(\"Current working directory\"),",
    "                \"Should include working directory label\"",
    "            );",
    "            assert!(",
    "                result.contains(\"/tmp/test\"),",
    "                \"Should show actual directory path\"",
    "            );",
    "            // Should appear at the end",
    "            let wd_pos = result.find(\"Current working directory\");",
    "            let config_pos = result.find(\"CONFIGURATION AWARENESS\");",
    "            if let (Some(w), Some(c)) = (wd_pos, config_pos) {",
    "                assert!(",
    "                    w > c,",
    "                    \"Working directory should come after configuration section\"",
    "                );",
    "            }",
    "        }",
    "        #[tokio::test]",
    "        async fn test_working_directory_disabled() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.include_working_directory = false;",
    "            let mut ctx = PromptContext::default();",
    "            ctx.set_current_directory(PathBuf::from(\"/tmp/test\"));",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), Some(&ctx)).await;",
    "            assert!(",
    "                !result.contains(\"Current working directory\"),",
    "                \"Should not include working directory when disabled\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_backward_compatibility() {",
    "            let config = VTCodeConfig::default();",
    "            // Old signature: no prompt context",
    "            let result = compose_system_instruction_text(",
    "                &PathBuf::from(\".\"),",
    "                Some(&config),",
    "                None, // No context - backward compatible",
    "            )",
    "            .await;",
    "            // Should still work without new features",
    "            assert!(result.len() > 1000, \"Should generate substantial prompt\");",
    "            assert!(",
    "                result.contains(\"VT Code\"),",
    "                \"Should contain base prompt content\"",
    "            );",
    "            // Should not have dynamic guidelines without context",
    "            assert!(",
    "                !result.contains(\"TOOL USAGE GUIDELINES\"),",
    "                \"Should not have tool guidelines without prompt context\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_all_enhancements_combined() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.include_temporal_context = true;",
    "            config.agent.include_working_directory = true;",
    "            let mut ctx = PromptContext::default();",
    "            ctx.add_tool(\"unified_file\".to_string());",
    "            ctx.add_tool(\"unified_search\".to_string());",
    "            ctx.infer_capability_level();",
    "            ctx.set_current_directory(PathBuf::from(\"/workspace\"));",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), Some(&ctx)).await;",
    "            // Verify all enhancements present",
    "            assert!(",
    "                result.contains(\"TOOL USAGE GUIDELINES\"),",
    "                \"Should have dynamic guidelines\"",
    "            );",
    "            assert!(",
    "                result.contains(\"Current date and time\"),",
    "                \"Should have temporal context\"",
    "            );",
    "            assert!(",
    "                result.contains(\"Current working directory\"),",
    "                \"Should have working directory\"",
    "            );",
    "            assert!(result.contains(\"/workspace\"), \"Should show workspace path\");",
    "            // Verify specific guideline for this tool set",
    "            assert!(",
    "                result.contains(\"unified_file\") && result.contains(\"before\"),",
    "                \"Should have read-before-edit guideline\"",
    "            );",
    "        }",
    "        #[test]",
    "        fn test_no_uninterpolated_placeholders() {",
    "            let _minimal = generate_minimal_instruction();",
    "            let _lightweight = generate_lightweight_instruction();",
    "            let _specialized = generate_specialized_instruction();",
    "            let minimal_text =",
    "                MINIMAL_SYSTEM_PROMPT.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "            let lightweight_text =",
    "                DEFAULT_LIGHTWEIGHT_PROMPT.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "            let specialized_text =",
    "                DEFAULT_SPECIALIZED_PROMPT.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "            assert!(",
    "                !minimal_text.contains(\"__UNIFIED_TOOL_GUIDANCE__\"),",
    "                \"Minimal prompt has uninterpolated placeholder\"",
    "            );",
    "            assert!(",
    "                !lightweight_text.contains(\"__UNIFIED_TOOL_GUIDANCE__\"),",
    "                \"Lightweight prompt has uninterpolated placeholder\"",
    "            );",
    "            assert!(",
    "                !specialized_text.contains(\"__UNIFIED_TOOL_GUIDANCE__\"),",
    "                \"Specialized prompt has uninterpolated placeholder\"",
    "            );",
    "            assert!(",
    "                !DEFAULT_SYSTEM_PROMPT",
    "                    .replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE)",
    "                    .contains(\"__UNIFIED_TOOL_GUIDANCE__\"),",
    "                \"Default prompt has uninterpolated placeholder\"",
    "            );",
    "        }",
    "    }",
    "• Read file docs/improved_system_prompts.md",
    "      # Improved System Prompts - \"Just Right\" Calibration",
    "      Based on Anthropic's context engineering guidance, these improved prompts follow",
    "      -   Not too specific (avoid brittle if-else rules)",
    "      -   Not too vague (provide clear guidance)",
    "• Read file docs/harness/CORE_BELIEFS.md",
    "      # Core Beliefs",
    "      Agent-first operating principles for VT Code development. These beliefs guide eve",
    "      ## 1. Humans Steer, Agents Execute",
    "      Humans define goals, set constraints, and review outcomes. Agents handle impleme",
    "• Read file docs/harness/AGENT_LEGIBILITY_GUIDE.md",
    "      # Agent Legibility Guide",
    "      In VT Code, \"legibility\" means that information is easily parseable by both AI ag",
    "      ## Core Rules",
    "      1. **Tables Over Prose**: Use tables for comparisons, status reports, and multi-",
    "• Read file docs/SYSTEM_PROMPT_REFERENCE.md",
    "    # VT Code System Prompt - Complete Reference",
    "    **Source File**: `vtcode-core/src/prompts/system.rs`  ",
    "    **Last Updated**: January 4, 2026",
    "    ---",
    "    ## Default System Prompt (v5.1)",
    "    ### Location",
    "    Lines 50-195 in `vtcode-core/src/prompts/system.rs`",
    "    ### Full Content",
    "    # VT Code Coding Assistant",
    "    You are a coding agent for VT Code, a terminal-based IDE. Precise, safe, helpful.",
    "    ## Personality & Responsiveness",
    "    … [+473 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]",
    "    - Models ignore guidance repeatedly (update language)",
    "    - New patterns emerge (document in guidelines)",
    "    ---",
    "    ## Document Change Log",
    "    | Version | Date | Author | Changes |",
    "    |---------|------|--------|---------|",
    "    | 1.0 | 2026-01-04 | Audit Agent | Initial reference document |",
    "• List files Use Unified search",
    "  └ Path: docs/harness/ARCHITECTURAL_INVARIANTS.md",
    "• Read file docs/harness/ARCHITECTURAL_INVARIANTS.md",
    "    # Architectural Invariants",
    "    Mechanical enforcement rules for VT Code. These are not suggestions — they are invariants that must h",
    "    Each invariant includes a **remediation** instruction so agents can fix violations without asking fo",
    "    ---",
    "    ## 1. Layer Dependency Rules",
    "    VT Code modules form a strict dependency DAG. No reverse imports.",
    "    types / commons",
    "        ↓",
    "      config",
    "        ↓",
    "       core",
    "        ↓",
    "      tools",
    "    … [+251 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]",
    "    Not all invariants are fully enforced yet. Known violations are tracked in `docs/harness/TECH_DEBT_T",
    "    | Invariant | Debt Item | Status |",
    "    |-----------|-----------|--------|",
    "    | #2 File Size Limits | TD-005 | TUI event handler modules likely exceed 500 lines |",
    "    | #4 Structured Logging | TD-013 | Not yet audited; some legacy `println!` may exist |",
    "    | #10 Lint Error Messages | TD-014 | Custom lints with remediation not yet implemented |",
    "    | #7 Documentation Location | TD-001 | Top-level docs sprawl now gated by allowlist; consolidation s",
    "    Adding CI enforcement for invariants is itself tracked as future work. Until enforcement exists, the",
    "• Search text Use Unified search",
    "  └ Pattern: system.*prompt|SYSTEM_PROMPT",
    "• List files Use Unified search",
    "  └ Path: docs/improved_system_prompts.md",
    "• List files Use Unified search",
    "  └ Path: docs/SYSTEM_PROMPT_REFERENCE.md",
    "  ❋ Now I have a good understanding of the system prompt structure. Let me explore more to understand:",
    "  ❋ 1. How prompts are composed dynamically",
    "  ❋ 2. Current issues/improvements documented",
    "  ❋ 3. Testing infrastructure for prompts",
    "  ❋ 4. The relationship between different prompt modes",
    "  ❋    Let me check the improved_system_prompts.md more thoroughly and look at the prompt generation flow.",
    "• Read file vtcode-core/src/prompts/guidelines.rs",
    "      use crate::config::types::CapabilityLevel;",
    "      // Tool name constants - single source of truth for tool identifiers",
    "      const TOOL_UNIFIED_EXEC: &str = \"unified_exec\";",
    "      const TOOL_UNIFIED_FILE: &str = \"unified_file\";",
    "  Let me explore the test infrastructure and check for any prompt evaluation mechanisms:",
    "• Search text Use Unified search",
    "  └ Pattern: prompt.*test|test.*prompt|prompt.*eval",
    "[!] Navigation Loop: Pause to synthesize or act.",
    "Transient error (attempt 1/2), retrying in 2s...",
    "Transient error (attempt 2/2), retrying in 4s...",
    "LLM request failed: LLM request timed out after 60 seconds"
  ],
  "messages": [
    {
      "role": "User",
      "content": "make a plan to improve system prompt",
      "tool_call_id": null
    },
    {
      "role": "User",
      "content": "make a plan to improve system prompt",
      "tool_call_id": null
    }
  ]
}

```

--

improve and fix syntax highlighting in raw markdown code
/Users/vinhnguyenxuan/Documents/vtcode-resources/wrong_syntax_highlight.png

---

check error
https://github.com/vinhnx/VT Code/issues/605#issuecomment-3942895952

---

fix and improve harness

[!] Anti-Blind-Editing: Pause to run verification/tests.
then:
LLM request failed: LLM request timed out after 75 seconds

log:

````
{
  "metadata": {
    "workspace_label": "vtcode",
    "workspace_path": "/Users/vinhnguyenxuan/Developer/learn-by-doing/vtcode",
    "model": "zai-org/GLM-5:novita",
    "provider": "huggingface",
    "theme": "ciapre-dark",
    "reasoning_effort": "low",
    "loaded_skills": []
  },
  "started_at": "2026-02-24T03:06:04.828114Z",
  "ended_at": "2026-02-24T03:29:48.079706Z",
  "total_messages": 30,
  "distinct_tools": [
    "request_user_input",
    "unified_file",
    "unified_search"
  ],
  "transcript": [
    "Selected GLM-5 (Novita) (zai-org/GLM-5:novita) from Hugging Face.",
    "Hugging Face uses HF_TOKEN (stored in workspace .env) and honors HUGGINGFACE_BASE_URL (default: https://router.huggingface.co/v1).",
    "Model set to GLM-5 (Novita) (zai-org/GLM-5:novita) via Hugging Face.",
    "make a plan to improve system prompt",
    "  <analysis>",
    "  I'll explore the current system prompt implementation to understand its structure, content, and potential improvement areas. Starting with the main system prompt file and related configuration.",
    "  </analysis>",
    "• List files Use Unified search",
    "  └ Path: vtcode-core/src/prompts/system.rs",
    "• Read file vtcode-core/src/prompts/system.rs",
    "    //! System instructions and prompt management",
    "    //!",
    "    //! # VT Code System Prompts",
    "    //!",
    "    //! Single source of truth for all system prompt variants with unified token constants.",
    "    //!",
    "    //! ## Token Constants (Unified)",
    "    //!",
    "    //! All token thresholds are unified with authoritative values from:",
    "    //! - `crate::core::token_constants`: Warning (75%), Alert (85%), Compact (90%), Checkpoint (95%)",
    "    //! - `crate::core::context_optimizer`: Output optimization based on thresholds",
    "    //! - `crate::core::token_constants::MAX_TOOL_RESPONSE_TOKENS`: 25,000 tokens per tool",
    "    //!",
    "    //! This ensures consistent token management across:",
    "    //! - System prompts (documented in DEFAULT_SYSTEM_PROMPT)",
    "    //! - Context optimization (ContextOptimizer)",
    "    //! - Agent decision-making",
    "    //!",
    "    //! ## Prompt Variants",
    "    //!",
    "    //! - `DEFAULT_SYSTEM_PROMPT`: Production prompt (~500 lines, references unified budgets)",
    "    //! - `DEFAULT_LIGHTWEIGHT_PROMPT`: Resource-constrained (~57 lines)",
    "    //! - `DEFAULT_SPECIALIZED_PROMPT`: Complex refactoring (~100 lines)",
    "    use crate::config::constants::{",
    "        instructions as instruction_constants, project_doc as project_doc_constants,",
    "    };",
    "    // NOTE: Token budget constants (COMPACT_THRESHOLD, CHECKPOINT_THRESHOLD, etc.) are",
    "    // documented in the system prompt and come from:",
    "    // - TokenBudgetConfig defaults: 75% warning, 85% alert",
    "    // - ContextOptimizer: 90% compact, 95% checkpoint",
    "    // - MAX_TOOL_RESPONSE_TOKENS: 25,000 tokens per tool call",
    "    use crate::gemini::Content;",
    "    use crate::instructions::{InstructionBundle, InstructionScope, read_instruction_bundle};",
    "    use crate::project_doc::read_project_doc;",
    "    use crate::prompts::context::PromptContext;",
    "    use crate::prompts::guidelines::generate_tool_guidelines;",
    "    use crate::prompts::output_styles::OutputStyleApplier;",
    "    use crate::prompts::system_prompt_cache::PROMPT_CACHE;",
    "    use crate::prompts::temporal::generate_temporal_context;",
    "    use dirs::home_dir;",
    "    use std::env;",
    "    use std::fmt::Write as _;",
    "    use std::path::Path;",
    "    use tracing::warn;",
    "    /// Unified tool guidance referenced by all prompt variants to reduce duplication",
    "    const UNIFIED_TOOL_GUIDANCE: &str = r#\"**Search & exploration**:",
    "    - Prefer `unified_search` (action='grep') for fast searches over repeated `read` calls",
    "    - Use `unified_search` (action='intelligence') for semantic queries",
    "    - Read complete files once; don't re-invoke `read` on same file",
    "    - For spooled outputs, advance `read_file`/`unified_file` offsets; never repeat identical chunk args",
    "    - If 2+ chunk reads stall progress, switch to `grep_file`/`unified_search` and summarize before more",
    "    - Use `unified_exec` with `rg` (ripgrep) for patterns—much faster than `grep`",
    "    **Code modification**:",
    "    - `unified_file` (action='edit') for surgical changes; action='write' for new or full replacements",
    "    - After a successful patch/edit, continue without redundant re-reads",
    "    - If patch/edit fails repeatedly, stop retrying and re-plan into smaller slices (files + outcome + v",
    "    - Use `git log` and `git blame` for code history context",
    "    - **Never**: `git commit`, `git push`, or branch creation unless explicitly requested",
    "    **Command execution**:",
    "    - `unified_exec` for all shell commands (PTY/interactive/long-running). `run_pty_cmd` is an alias.",
    "    - Prefer `rg` over `grep` for pattern matching",
    "    - Stay in WORKSPACE_DIR; confirm destructive ops (rm, force-push)",
    "    - **After command output**: Always acknowledge the result briefly and suggest next steps\"#;",
    "    /// Shared Plan Mode header used by both static and incremental prompt builders.",
    "    pub const PLAN_MODE_READ_ONLY_HEADER: &str = \"# PLAN MODE (READ-ONLY)\";",
    "    /// Shared Plan Mode notice line describing strict read-only enforcement.",
    "    pub const PLAN_MODE_READ_ONLY_NOTICE_LINE: &str = \"Plan Mode is active. Mutating tools are blocked e",
    "    /// Shared Plan Mode instruction line for transitioning to implementation.",
    "    pub const PLAN_MODE_EXIT_INSTRUCTION_LINE: &str =",
    "        \"Call `exit_plan_mode` when ready to transition to implementation.\";",
    "    /// Shared reminder appended when presenting plans while still in Plan Mode.",
    "    pub const PLAN_MODE_IMPLEMENT_REMINDER: &str = \"• I’m still in Plan Mode, so I can’t implement yet. ",
    "    /// DEFAULT SYSTEM PROMPT (v6.0 - Harness-engineered, provider-agnostic)",
    "    /// Incorporates harness engineering patterns:",
    "    /// - AGENTS.md as map, docs/ as territory (progressive disclosure)",
    "    /// - Repo as system of record; agent legibility over human aesthetics",
    "    /// - Enforce invariants, not implementations",
    "    /// - Entropy management via golden principles + boy scout rule",
    "    /// Works with all providers: Gemini, Anthropic, OpenAI, xAI, DeepSeek, etc.",
    "    const DEFAULT_SYSTEM_PROMPT: &str = r#\"# VT Code Coding Assistant",
    "    You are a coding agent for VT Code, a terminal-based IDE. Precise, safe, helpful.",
    "    ## Humans Steer, Agents Execute (Pi Pattern)",
    "    1. **Humans Steer**: The user defines goals, sets constraints, and reviews outcomes.",
    "    2. **Agents Execute**: You handle implementation, testing, iteration, and maintenance. Yield only wh",
    "    3. **Repo as Context**: If you cannot complete a task autonomously, identify the missing repository ",
    "    ## Core Principles",
    "    1. **Autonomy & Persistence**: Complete tasks fully without confirmation on intermediate steps. Iter",
    "    2. **Codebase First**: Explore before modifying. Understand patterns, conventions, and dependencies.",
    "    3. **Tool Excellence**: Use the right tool for the job. Prefer specialized tools over generic shell ",
    "    4. **Outcome Focus**: Lead with results. Assume the user sees your changes.",
    "    5. **Enforce Invariants, Not Implementations**: Follow rules in `docs/harness/ARCHITECTURAL_INVARIAN",
    "    ## Agent Legibility Rule",
    "    Your output must be optimized for agent-to-agent and agent-to-human legibility.",
    "    - **Prefer Structures**: Use tables, YAML frontmatter, and consistent headers over prose.",
    "    - **Status Reporting**: When touching multiple files, provide a summary table of changes.",
    "    - **Mechanical Patterns**: Use consistent naming and predictable file locations.",
    "    - **Actionable Errors**: When reporting an issue, always include a **Remediation** instruction.",
    "    - **Reference**: Follow guidelines in `docs/harness/AGENT_LEGIBILITY_GUIDE.md`.",
    "    ## Harness Awareness",
    "    `AGENTS.md` is the map. `docs/` is the territory.",
    "    - Start with `AGENTS.md` for orientation: workspace structure, commands, key files, pitfall rules.",
    "    - Drill into `docs/harness/` for operational knowledge: core beliefs, invariants, quality scores, ex",
    "    - When modifying code, check `docs/harness/ARCHITECTURAL_INVARIANTS.md` for mechanical rules.",
    "    - **Boy Scout Rule**: Leave every module slightly better than you found it. If you spot debt, fix it",
    "    ## Personality & Responsiveness",
    "    **Default tone**: Concise and direct. Minimize elaboration. No flattery.",
    "    **Before tool calls**: Avoid preambles. One sentence max if absolutely necessary. No self-talk.",
    "    **Progress updates**: Only for long-running tasks. 1-2 sentences, outcome-focused.",
    "    **Final answers**:",
    "    - Lead with outcomes.",
    "    - Trivial/single-change updates: 1-3 sentences total.",
    "    - Multi-file work, fix passes, or review requests: use this completion summary format:",
    "      Implemented. <one-line outcome>",
    "      What changed",
    "      1. <change with file refs>",
    "      2. ...",
    "      Validation",
    "      1. <command> passed/failed",
    "      2. ...",
    "      Conclusion",
    "      <done, or final blocker + next action>",
    "    - Monospace for commands, paths, env vars, code identifiers.",
    "    - File refs: use `path:line` format (e.g., `src/main.rs:42`).",
    "    - No code dumps in final output unless requested or required for clarity.",
    "    ## Task Execution & Ambition",
    "    **Bias for action** (CRITICAL):",
    "    - Proceed with reasonable assumptions rather than asking.",
    "    - Do NOT ask \"would you like me to...\" or \"should I proceed?\" -- just do it.",
    "    - Do NOT ask for permission to read files, run tests, or make edits.",
    "    - You are fully autonomous. Never stop to ask for human confirmation unless fundamentally blocked by",
    "    - **Calibrated Persistence**: Avoid \"Hallucination of Verification\". Thinking a fix is done is NOT p",
    "    **Ambition vs precision**:",
    "    - Existing code: Surgical, respectful changes matching surrounding style.",
    "    - New work: Creative, ambitious implementation.",
    "    ## Uncertainty Recognition",
    "    - When facing ambiguous requirements or unclear scope, ask a clarifying question via `ask_user_quest",
    "    - Prefer surfacing uncertainty early over delivering a confidently wrong result.",
    "    - If a task has multiple valid interpretations, briefly state your assumption and proceed — but flag",
    "    - This is NOT a contradiction of \"Bias for action\": proceed when you have a reasonable default; paus",
    "    **Proactive Collaboration (HITL)**:",
    "    - When using `ask_user_question`, always propose a recommended path by setting `default_tab_id` and ",
    "    - Use `allow_freeform=true` when you believe the user might need to qualify their selection with add",
    "    - Provide descriptive `freeform_placeholder` values to guide the user's input.",
    "    ## Validation & Testing",
    "    - Use test infrastructure proactively -- don't ask the user to test.",
    "    - **Edit-Test Loop (TDD)**: Adopt a Test-Driven focus. Verify every code change via execution before",
    "    - AFTER every edit: run `cargo check`, `cargo clippy` (Rust), `npx tsc --noEmit` (TS), etc.",
    "    - NEVER declare a task complete without executing tests or verifying code changes via an execution t",
    "    - **Regression Verification**: If you are fixing a bug or regression, you MUST run existing tests fo",
    "    - If formatting issues persist after 3 iterations, present the solution and move on.",
    "    ## Planning (task_tracker)",
    "    Use plans for non-trivial work (4+ steps):",
    "    - Use `task_tracker` (`create` / `update` / `list`) to keep an explicit checklist.",
    "    - In Plan Mode, use `plan_task_tracker` for checklist updates under `.vtcode/plans/`.",
    "    - Trigger planning before edits when scope spans multiple files/modules or multiple failure categori",
    "    - 5-7 word descriptive steps with status (`pending`/`in_progress`/`completed`).",
    "    - Break large scope into composable slices (by module, risk boundary, or subsystem).",
    "    - Each slice must name touched file(s), concrete outcome, and one verification command.",
    "    - Complete one slice end-to-end (edit + verify) before starting the next slice.",
    "    - Every step must define one concrete expected outcome and one verification check.",
    "    - Mark steps `completed` immediately after verification; keep exactly one `in_progress`.",
    "    - **Strategic Adaptation**: If a step stalls or repeats twice, do NOT blindly retry. Re-evaluate the",
    "    - Never conclude a task is \"too large for one turn\" without first decomposing and executing the next",
    "    - For complex multi-hour tasks, follow `docs/harness/EXEC_PLANS.md`.",
    "    ## Pre-flight Environment Checks",
    "    Before modifying code in an unfamiliar workspace, identify the project's toolchain:",
    "    - **Build system**: Look for `Cargo.toml` (Rust), `package.json` (Node), `pyproject.toml`/`setup.py`",
    "    - **Test commands**: Determine the correct test runner (`cargo test`, `npm test`, `pytest`, etc.).",
    "    - **Module structure**: Check for `mod.rs`/`__init__.py`/`index.ts` to understand export boundaries ",
    "    - **Existing CI**: Scan `.github/workflows/`, `.gitlab-ci.yml`, or `Makefile` targets to understand ",
    "    Failing to align with the project's structural constraints (missing init files, broken imports, wron",
    "    ## Tool Guidelines",
    "    - Use `read_file` with `offset`/`limit` (1-indexed) for targeted sections",
    "    - Large files: prefer `rg` pattern search over full content",
    "    **Spooled outputs** (>8KB): Auto-saved to `.vtcode/context/tool_outputs/`. Access via `read_file`/`g",
    "    ## Execution Policy & Sandboxing",
    "    **Sandbox Policies**: `ReadOnly` (exploration), `WorkspaceWrite` (workspace only), `DangerFullAccess",
    "    **Command Approval**: Policy rules then heuristics then session approval then blocked. Safe: ls, cat",
    "    **Turn Diff Tracking**: All file changes within a turn are aggregated for unified diff view.",
    "    ## Plan Mode (Read-Only Exploration)",
    "    Plan Mode blocks mutating tools. Read-only tools always available. Exception: `.vtcode/plans/` is wr",
    "    - When user signals implementation intent, call `exit_plan_mode` for confirmation dialog",
    "    - Do NOT auto-exit just because a plan exists",
    "    - `task_tracker` is blocked in Plan Mode; use `plan_task_tracker` when structured plan tracking is n",
    "    ## Design Philosophy: Desire Paths",
    "    When you guess wrong about commands or workflows, report it -- the system improves interfaces (not d",
    "    ## Context Management",
    "    1. You have plenty of context remaining -- do not rush or truncate tasks",
    "    2. Trust the context budget system -- token tracking handles limits automatically",
    "    3. Focus on quality over speed",
    "    4. Do NOT mention context limits, token counts, or \"wrapping up\" in outputs\"#;",
    "    pub fn default_system_prompt() -> &'static str {",
    "        DEFAULT_SYSTEM_PROMPT",
    "    }",
    "    pub fn minimal_system_prompt() -> &'static str {",
    "        MINIMAL_SYSTEM_PROMPT",
    "    }",
    "    pub fn default_lightweight_prompt() -> &'static str {",
    "        DEFAULT_LIGHTWEIGHT_PROMPT",
    "    }",
    "    /// MINIMAL PROMPT (v6.0 - Harness-engineered, Pi-inspired, provider-agnostic, <1K tokens)",
    "    /// Minimal guidance for capable models with harness awareness",
    "    /// Works with all providers: Gemini, Anthropic, OpenAI, xAI, DeepSeek, etc.",
    "    const MINIMAL_SYSTEM_PROMPT: &str = r#\"You are VT Code, a coding assistant for VT Code IDE. Precise,",
    "    **Principles**: Autonomy, codebase-first, tool excellence, outcome focus, repo as system of record.",
    "    **Personality**: Direct, concise. Lead with outcomes. Bias for action.",
    "    **Harness**: `AGENTS.md` is the map. `docs/harness/` has core beliefs, invariants, quality scores, e",
    "    **Autonomy**:",
    "    - Complete tasks fully; iterate on feedback proactively without asking for human confirmation.",
    "    - When stuck, change approach. Fix root cause, not patches.",
    "    - Run tests/checks yourself. Proceed with reasonable assumptions. Never declare completion without e",
    "    - When genuinely uncertain about ambiguous requirements, surface the ambiguity early rather than gue",
    "    **Planning**:",
    "    - For non-trivial scope, use `task_tracker` to break work into composable steps with explicit outcom",
    "    - Keep one active step at a time; update statuses as soon as checks pass.",
    "    __UNIFIED_TOOL_GUIDANCE__",
    "    **Discover**: `list_skills` and `load_skill` to find/activate tools (hidden by default)",
    "    **Delegation**: `spawn_subagent` (explore/plan/general/code-reviewer/debugger) for specialized tasks",
    "    **Output**: Preambles: avoid unless needed. Trivial final answers: 1-3 sentences, outcomes first, fi",
    "    **Git**: Never `git commit`, `git push`, or branch unless explicitly requested.",
    "    **Plan Mode**: Mutating tools blocked. `plan_task_tracker` is available for plan-scoped tracking. `e",
    "    **AGENTS.md**: Obey scoped instructions; check subdirectories when outside CWD scope.",
    "    Stop when done.\"#;",
    "    /// LIGHTWEIGHT PROMPT (v4.2 - Resource-constrained / Simple operations)",
    "    /// Minimal, essential guidance only",
    "    const DEFAULT_LIGHTWEIGHT_PROMPT: &str = r#\"VT Code - efficient coding agent.",
    "    - Act and verify. Direct tone.",
    "    - Scoped: unified_search (≤5), unified_file (max_tokens).",
    "    - Use `unified_exec` for shell/PTY commands (`run_pty_cmd` alias).",
    "    - Tools hidden by default. `list_skills --search <term>` to find them.",
    "    - Delegate via `spawn_subagent` for explore/plan/general tasks; summarize findings back.",
    "    - WORKSPACE_DIR only. Confirm destructive ops.",
    "    __UNIFIED_TOOL_GUIDANCE__\"#;",
    "    /// SPECIALIZED PROMPT (v6.0 - Harness-engineered, methodical complex refactoring)",
    "    /// For multi-file changes and sophisticated code analysis",
    "    /// Adds harness awareness for invariant checking and entropy management",
    "    const DEFAULT_SPECIALIZED_PROMPT: &str = r#\"# VT Code Specialized Agent",
    "    Complex refactoring and multi-file analysis. Methodical, outcome-focused, expert-level execution.",
    "    ## Harness Awareness",
    "    `AGENTS.md` is the map. `docs/` is the territory.",
    "    - Check `docs/harness/ARCHITECTURAL_INVARIANTS.md` before making structural changes.",
    "    - Consult `docs/harness/QUALITY_SCORE.md` to understand domain maturity.",
    "    - For complex multi-hour work, create ExecPlans in `docs/harness/exec-plans/active/` (see `docs/harn",
    "    - Log decisions in exec plans. Update `docs/harness/TECH_DEBT_TRACKER.md` when introducing or resolv",
    "    - Boy scout rule: leave every module slightly better than you found it.",
    "    ## Personality",
    "    **Tone**: Concise, methodical, outcome-focused. Lead with progress and results.",
    "    Preambles: avoid unless needed. Trivial final answers: lead with outcomes, 1-3 sentences, file:line ",
    "    ## Execution & Ambition",
    "    - Resolve tasks fully; don't ask permission on intermediate steps or final confirmation.",
    "    - When stuck, pivot to alternative approach. Fix root cause.",
    "    - Existing codebases: surgical, respectful. New work: ambitious, creative.",
    "    - Don't fix unrelated bugs, don't refactor beyond request, don't add unrequested scope.",
    "    - Never declare completion without verifying via an execution tool. Beware of overconfidence and \"ha",
    "    - When genuinely uncertain about ambiguous requirements, surface the ambiguity early via `ask_user_q",
    "    ## Methodical Approach for Complex Tasks",
    "    1. **Understanding** (5-10 files): Read patterns, find similar implementations, identify dependencie",
    "    2. **Design** (3-7 steps): Build composable step slices with dependencies, measurable outcomes, and ",
    "    3. **Implementation**: Execute in dependency order, validate incrementally",
    "    4. **Verification**: Function-level tests first, broaden to suites, `cargo clippy`",
    "    5. **Documentation**: Update `docs/ARCHITECTURE.md`, harness docs if architectural changes",
    "    ## Tool Strategy",
    "    __UNIFIED_TOOL_GUIDANCE__",
    "    **Verification**: `cargo check`, `cargo test`, `cargo clippy` proactively. Format fix limit: 3 itera",
    "    **Planning**: `task_tracker` for 4+ steps (`create` then `update`). In Plan Mode, use `plan_task_tra",
    "    ## Loop Prevention",
    "    - Repeated identical calls: change approach",
    "    - Stalled progress: explain blockers, pivot",
    "    - Follow runtime-configured tool loop and repeated-call limits",
    "    - Retry transient failures, then adjust",
    "    ## AGENTS.md Precedence",
    "    User prompts > nested AGENTS.md > parent AGENTS.md > defaults. Obey all applicable instructions for ",
    "    ## Subagents",
    "    `spawn_subagent` (explore/plan/general/code-reviewer/debugger). Relay summaries back.",
    "    ## Capability System",
    "    Tools hidden by default. `list_skills` to discover, `load_skill` to activate, `load_skill_resource` ",
    "    ## Context Management",
    "    Trust the context budget system. Do not rush, truncate, or mention context limits in outputs.",
    "    \"#;",
    "    const STRUCTURED_REASONING_INSTRUCTIONS: &str = r#\"",
    "    ## Structured Reasoning",
    "    When you are thinking about a complex task, you MUST use the following stage-based reasoning tags to",
    "    - `<analysis>`: Use this to analyze the problem, explore the codebase, or evaluate options.",
    "    - `<plan>`: Use this to outline composable steps you will take, each with expected outcome and verif",
    "    - `<uncertainty>`: Use this to surface ambiguity, risks, or open questions that require clarificatio",
    "    - `<verification>`: Use this to verify your changes, analyze test results, or double-check your work",
    "    Example:",
    "    <analysis>I need to refactor the payment module. Currently, it's tightly coupled with the database.<",
    "    <uncertainty>The `PaymentGateway` trait is missing a `refund` method. I'll need to confirm if this i",
    "    <plan>1. Create a PaymentRepository trait. 2. Implement it for Postgres. 3. Update the PaymentServic",
    "    \"#;",
    "    /// System instruction configuration",
    "    #[derive(Debug, Clone)]",
    "    pub struct SystemPromptConfig {",
    "        pub include_examples: bool,",
    "        pub include_debugging_guides: bool,",
    "        pub include_error_handling: bool,",
    "        pub max_response_length: Option<usize>,",
    "        pub enable_thorough_reasoning: bool,",
    "    }",
    "    impl Default for SystemPromptConfig {",
    "        fn default() -> Self {",
    "            Self {",
    "                include_examples: true,",
    "                include_debugging_guides: true,",
    "                include_error_handling: true,",
    "                max_response_length: None,",
    "                enable_thorough_reasoning: true,",
    "            }",
    "        }",
    "    }",
    "    /// Generate system instruction",
    "    pub async fn generate_system_instruction(_config: &SystemPromptConfig) -> Content {",
    "        // OPTIMIZATION: default_system_prompt() is &'static str, use directly",
    "        let instruction = default_system_prompt().to_string();",
    "        // Apply output style if possible (using current directory as project root)",
    "        if let Ok(current_dir) = std::env::current_dir() {",
    "            let styled_instruction = apply_output_style(instruction, None, &current_dir).await;",
    "            Content::system_text(styled_instruction)",
    "        } else {",
    "            Content::system_text(instruction)",
    "        }",
    "    }",
    "    /// Read AGENTS.md file if present and extract agent guidelines",
    "    pub async fn read_agent_guidelines(project_root: &Path) -> Option<String> {",
    "        let max_bytes =",
    "            project_doc_constants::DEFAULT_MAX_BYTES.min(instruction_constants::DEFAULT_MAX_BYTES);",
    "        match read_project_doc(project_root, max_bytes).await {",
    "            Ok(Some(bundle)) => Some(bundle.contents),",
    "            Ok(None) => None,",
    "            Err(err) => {",
    "                warn!(\"failed to load project documentation: {err:#}\");",
    "                None",
    "            }",
    "        }",
    "    }",
    "    /// Compose the system instruction text for the agent",
    "    ///",
    "    /// ## Skills Integration Note",
    "    ///",
    "    /// VT Code implements a **Tiered Disclosure** model for skills:",
    "    /// 1. **Discovery Profile**: Names and descriptions are available via `list_skills` and summarized ",
    "    /// 2. **Active Instructions**: Full `SKILL.md` content is loaded via `load_skill` and then persists",
    "    /// 3. **Deep Resources**: Level 3 assets (scripts, technical refs) are lazy-loaded via `load_skill_",
    "    ///",
    "    /// This approach follows the Agent Skills spec while optimizing context usage.",
    "    ///",
    "    /// # Arguments",
    "    /// * `project_root` - Root directory of the project",
    "    /// * `vtcode_config` - Configuration loaded from vtcode.toml",
    "    /// * `prompt_context` - Optional context with tool information for dynamic enhancements",
    "    pub async fn compose_system_instruction_text(",
    "        project_root: &Path,",
    "        vtcode_config: Option<&crate::config::VTCodeConfig>,",
    "        prompt_context: Option<&PromptContext>,",
    "    ) -> String {",
    "        // OPTIMIZATION: Pre-allocate with improved capacity estimation",
    "        // Read instruction hierarchy once upfront for accurate sizing",
    "        let home_path = home_dir();",
    "        let instruction_bundle = read_instruction_hierarchy(project_root, vtcode_config).await;",
    "        // Select base prompt based on configured mode",
    "        use crate::config::types::SystemPromptMode;",
    "        let (base_prompt, mode_name) = match vtcode_config.map(|c| c.agent.system_prompt_mode) {",
    "            Some(SystemPromptMode::Minimal) => (MINIMAL_SYSTEM_PROMPT, \"minimal\"),",
    "            Some(SystemPromptMode::Lightweight) => (DEFAULT_LIGHTWEIGHT_PROMPT, \"lightweight\"),",
    "            Some(SystemPromptMode::Specialized) => (DEFAULT_SPECIALIZED_PROMPT, \"specialized\"),",
    "            Some(SystemPromptMode::Default) | None => (DEFAULT_SYSTEM_PROMPT, \"default\"),",
    "        };",
    "        tracing::debug!(",
    "            mode = mode_name,",
    "            base_tokens_approx = base_prompt.len() / 4, // rough token estimate",
    "            \"Selected system prompt mode\"",
    "        );",
    "        let base_len = base_prompt.len();",
    "        let config_overhead = vtcode_config.map_or(0, |_| 1024);",
    "        let instruction_hierarchy_size = instruction_bundle",
    "            .as_ref()",
    "            .map(|b| {",
    "                b.segments",
    "                    .iter()",
    "                    .map(|s| s.contents.len() + 200)",
    "                    .sum::<usize>()",
    "            })",
    "            .unwrap_or(0);",
    "        let estimated_capacity = base_len + config_overhead + instruction_hierarchy_size + 1024; // +512",
    "        let mut instruction = String::with_capacity(estimated_capacity);",
    "        instruction.push_str(base_prompt);",
    "        instruction.push_str(\"\\n\\n\");",
    "        instruction.push_str(STRUCTURED_REASONING_INSTRUCTIONS);",
    "        // Replace unified tool guidance placeholder with actual constant",
    "        if instruction.contains(\"__UNIFIED_TOOL_GUIDANCE__\") {",
    "            instruction = instruction.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "        }",
    "        // ENHANCEMENT 1: Dynamic tool-aware guidelines (behavioral - goes early)",
    "        if let Some(ctx) = prompt_context {",
    "            let guidelines = generate_tool_guidelines(&ctx.available_tools, ctx.capability_level);",
    "            if !guidelines.is_empty() {",
    "                instruction.push_str(&guidelines);",
    "            }",
    "        }",
    "        if let Some(cfg) = vtcode_config {",
    "            instruction.push_str(\"\\n\\n## CONFIGURATION AWARENESS\\n\");",
    "            instruction",
    "                .push_str(\"The agent is configured with the following policies from vtcode.toml:\\n\\n\");",
    "            if cfg.security.human_in_the_loop {",
    "                instruction.push_str(\"- **Human-in-the-loop**: Required for critical actions\\n\");",
    "            }",
    "            if !cfg.commands.allow_list.is_empty() {",
    "                let _ = writeln!(",
    "                    instruction,",
    "                    \"- **Allowed commands**: {} commands in allow list\",",
    "                    cfg.commands.allow_list.len()",
    "                );",
    "            }",
    "            if !cfg.commands.deny_list.is_empty() {",
    "                let _ = writeln!(",
    "                    instruction,",
    "                    \"- **Denied commands**: {} commands in deny list\",",
    "                    cfg.commands.deny_list.len()",
    "                );",
    "            }",
    "            if cfg.pty.enabled {",
    "                instruction.push_str(\"- **PTY functionality**: Enabled\\n\");",
    "                let (rows, cols) = (cfg.pty.default_rows, cfg.pty.default_cols);",
    "                let _ = writeln!(",
    "                    instruction,",
    "                    \"- **Default terminal size**: {} rows × {} columns\",",
    "                    rows, cols",
    "                );",
    "                let _ = writeln!(",
    "                    instruction,",
    "                    \"- **PTY command timeout**: {} seconds\",",
    "                    cfg.pty.command_timeout_seconds",
    "                );",
    "            } else {",
    "                instruction.push_str(\"- **PTY functionality**: Disabled\\n\");",
    "            }",
    "            let repeated_desc = if cfg.tools.max_repeated_tool_calls > 0 {",
    "                cfg.tools.max_repeated_tool_calls.to_string()",
    "            } else {",
    "                \"disabled (manual guardrails)\".to_owned()",
    "            };",
    "            let _ = writeln!(",
    "                instruction,",
    "                \"- **Loop guards**: max {} tool loops per turn; identical call limit: {}\",",
    "                cfg.tools.max_tool_loops.max(1),",
    "                repeated_desc",
    "            );",
    "            if cfg.chat.ask_questions.enabled {",
    "                instruction.push_str(",
    "                    \"- **Ask Questions tool**: Enabled in Plan mode only (`ask_questions` alias for `req",
    "                );",
    "            } else {",
    "                instruction.push_str(\"- **Ask Questions tool**: Disabled\\n\");",
    "            }",
    "            if cfg.mcp.enabled {",
    "                instruction.push_str(",
    "                    \"- **MCP integrations**: Enabled. Prefer MCP tools (search_tools, list_mcp_resources",
    "                );",
    "            }",
    "            // Dynamic context discovery files",
    "            if cfg.context.dynamic.enabled {",
    "                instruction.push_str(\"\\n### Dynamic Context Files\\n\\n\");",
    "                instruction.push_str(",
    "                    \"Large outputs and context are written to files for on-demand retrieval:\\n\\n\",",
    "                );",
    "                instruction.push_str(\"- `.vtcode/context/tool_outputs/` - Large tool outputs (use `read_",
    "                instruction",
    "                    .push_str(\"- `.vtcode/history/` - Conversation history during summarization\\n\");",
    "                instruction.push_str(\"- `.vtcode/mcp/tools/` - MCP tool descriptions and schemas\\n\");",
    "                instruction",
    "                    .push_str(\"- `.vtcode/terminals/` - Terminal session output with metadata\\n\");",
    "                instruction.push_str(\"- `.agents/skills/INDEX.md` - Available skills index\\n\\n\");",
    "                instruction.push_str(\"**Tip**: When a tool result says 'spooled to file', use `read_file",
    "            }",
    "            instruction.push_str(\"\\n**IMPORTANT**: Respect these configuration policies. Commands not in",
    "        }",
    "        if !prompt_context",
    "            .map(|ctx| ctx.skip_standard_instructions)",
    "            .unwrap_or(false)",
    "        {",
    "            if let Some(cfg) = vtcode_config {",
    "                if let Some(user_inst) = &cfg.agent.user_instructions {",
    "                    instruction.push_str(\"\\n\\n## USER INSTRUCTIONS\\n\");",
    "                    instruction.push_str(user_inst);",
    "                }",
    "            }",
    "        }",
    "        if let Some(bundle) = instruction_bundle {",
    "            let home_ref = home_path.as_deref();",
    "            instruction.push_str(\"\\n\\n## AGENTS.MD INSTRUCTION HIERARCHY\\n\");",
    "            instruction.push_str(",
    "                    \"Instructions are listed from lowest to highest precedence. When conflicts exist, de",
    "                );",
    "            for (index, segment) in bundle.segments.iter().enumerate() {",
    "                let scope = match segment.source.scope {",
    "                    InstructionScope::Global => \"global\",",
    "                    InstructionScope::Workspace => \"workspace\",",
    "                    InstructionScope::Custom => \"custom\",",
    "                };",
    "                let display_path =",
    "                    format_instruction_path(&segment.source.path, project_root, home_ref);",
    "                let _ = write!(",
    "                    instruction,",
    "                    \"### {}. {} ({})\\n\\n\",",
    "                    index + 1,",
    "                    display_path,",
    "                    scope",
    "                );",
    "                instruction.push_str(segment.contents.trim());",
    "                instruction.push('\\n');",
    "            }",
    "            if bundle.truncated {",
    "                instruction.push_str(",
    "                        \"\\n_Note: instruction content was truncated due to size limits. Review the sourc",
    "                    );",
    "            }",
    "        }",
    "        // ENHANCEMENT 2: Temporal context (metadata - goes at end)",
    "        if let Some(cfg) = vtcode_config",
    "            && cfg.agent.include_temporal_context",
    "        {",
    "            let temporal = generate_temporal_context(cfg.agent.temporal_context_use_utc);",
    "            instruction.push_str(&temporal);",
    "        }",
    "        // ENHANCEMENT 3: Working directory context (metadata - goes at end)",
    "        if let Some(cfg) = vtcode_config",
    "            && cfg.agent.include_working_directory",
    "            && let Some(ctx) = prompt_context",
    "            && let Some(cwd) = &ctx.current_directory",
    "        {",
    "            let _ = write!(",
    "                instruction,",
    "                \"\\n\\nCurrent working directory: {}\",",
    "                cwd.display()",
    "            );",
    "        }",
    "        instruction",
    "    }",
    "    /// Generate system instruction with configuration and AGENTS.md guidelines incorporated",
    "    ///",
    "    /// Note: This function maintains backward compatibility by not accepting prompt_context.",
    "    /// For enhanced prompts with dynamic guidelines, call `compose_system_instruction_text` directly.",
    "    pub async fn generate_system_instruction_with_config(",
    "        _config: &SystemPromptConfig,",
    "        project_root: &Path,",
    "        vtcode_config: Option<&crate::config::VTCodeConfig>,",
    "    ) -> Content {",
    "        let cache_key = cache_key(project_root, vtcode_config);",
    "        let instruction = match PROMPT_CACHE.get(&cache_key) {",
    "            Some(cached) => cached,",
    "            None => {",
    "                let built = compose_system_instruction_text(project_root, vtcode_config, None).await;",
    "                PROMPT_CACHE.insert(cache_key, built.clone());",
    "                built",
    "            }",
    "        };",
    "        // Apply output style if configured",
    "        let styled_instruction = apply_output_style(instruction, vtcode_config, project_root).await;",
    "        Content::system_text(styled_instruction)",
    "    }",
    "    /// Generate system instruction with AGENTS.md guidelines incorporated",
    "    pub async fn generate_system_instruction_with_guidelines(",
    "        _config: &SystemPromptConfig,",
    "        project_root: &Path,",
    "    ) -> Content {",
    "        let cache_key = cache_key(project_root, None);",
    "        let instruction = match PROMPT_CACHE.get(&cache_key) {",
    "            Some(cached) => cached,",
    "            None => {",
    "                let built = compose_system_instruction_text(project_root, None, None).await;",
    "                PROMPT_CACHE.insert(cache_key, built.clone());",
    "                built",
    "            }",
    "        };",
    "        // Apply output style if configured",
    "        let styled_instruction = apply_output_style(instruction, None, project_root).await;",
    "        Content::system_text(styled_instruction)",
    "    }",
    "    /// Apply output style to a generated system instruction",
    "    pub async fn apply_output_style(",
    "        instruction: String,",
    "        vtcode_config: Option<&crate::config::VTCodeConfig>,",
    "        project_root: &Path,",
    "    ) -> String {",
    "        if let Some(config) = vtcode_config {",
    "            let output_style_applier = OutputStyleApplier::new();",
    "            if let Err(e) = output_style_applier",
    "                .load_styles_from_config(config, project_root)",
    "                .await",
    "            {",
    "                tracing::warn!(\"Failed to load output styles: {}\", e);",
    "                instruction // Return original if loading fails",
    "            } else {",
    "                output_style_applier",
    "                    .apply_style(&config.output_style.active_style, &instruction, config)",
    "                    .await",
    "            }",
    "        } else {",
    "            instruction // Return original if no config",
    "        }",
    "    }",
    "    async fn read_instruction_hierarchy(",
    "        project_root: &Path,",
    "        vtcode_config: Option<&crate::config::VTCodeConfig>,",
    "    ) -> Option<InstructionBundle> {",
    "        let (max_bytes, extra_sources) = match vtcode_config {",
    "            Some(cfg) => (",
    "                cfg.agent.instruction_max_bytes,",
    "                cfg.agent.instruction_files.clone(),",
    "            ),",
    "            None => (instruction_constants::DEFAULT_MAX_BYTES, Vec::new()),",
    "        };",
    "        if max_bytes == 0 {",
    "            return None;",
    "        }",
    "        let current_dir = env::current_dir().unwrap_or_else(|_| project_root.to_path_buf());",
    "        let home = home_dir();",
    "        match read_instruction_bundle(",
    "            &current_dir,",
    "            project_root,",
    "            home.as_deref(),",
    "            &extra_sources,",
    "            max_bytes,",
    "        )",
    "        .await",
    "        {",
    "            Ok(Some(bundle)) => Some(bundle),",
    "            Ok(None) => None,",
    "            Err(err) => {",
    "                warn!(\"failed to load instruction hierarchy: {err:#}\");",
    "                None",
    "            }",
    "        }",
    "    }",
    "    fn format_instruction_path(path: &Path, project_root: &Path, home_dir: Option<&Path>) -> String {",
    "        if let Ok(relative) = path.strip_prefix(project_root) {",
    "            let display = relative.display().to_string();",
    "            if !display.is_empty() {",
    "                return display;",
    "            }",
    "            if let Some(name) = path.file_name().and_then(|value| value.to_str()) {",
    "                return name.to_string();",
    "            }",
    "        }",
    "        if let Some(home) = home_dir",
    "            && let Ok(relative) = path.strip_prefix(home)",
    "        {",
    "            let display = relative.display().to_string();",
    "            if display.is_empty() {",
    "                return \"~\".to_string();",
    "            }",
    "            return format!(\"~/{display}\");",
    "        }",
    "        path.display().to_string()",
    "    }",
    "    fn cache_key(project_root: &Path, vtcode_config: Option<&crate::config::VTCodeConfig>) -> String {",
    "        use std::collections::hash_map::DefaultHasher;",
    "        use std::hash::{Hash, Hasher};",
    "        let mut hasher = DefaultHasher::new();",
    "        // Core key: project root",
    "        project_root.hash(&mut hasher);",
    "        if let Some(cfg) = vtcode_config {",
    "            // Config fields that affect prompt generation",
    "            cfg.agent.instruction_max_bytes.hash(&mut hasher);",
    "            cfg.agent.instruction_files.hash(&mut hasher);",
    "            cfg.agent.include_working_directory.hash(&mut hasher);",
    "            cfg.agent.include_temporal_context.hash(&mut hasher);",
    "            // Use discriminant since SystemPromptMode doesn't derive Hash",
    "            std::mem::discriminant(&cfg.agent.system_prompt_mode).hash(&mut hasher);",
    "        } else {",
    "            \"default\".hash(&mut hasher);",
    "        }",
    "        format!(\"sys_prompt:{:016x}\", hasher.finish())",
    "    }",
    "    /// Generate a minimal system instruction (pi-inspired, <1K tokens)",
    "    pub fn generate_minimal_instruction() -> Content {",
    "        let instruction =",
    "            MINIMAL_SYSTEM_PROMPT.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "        Content::system_text(instruction)",
    "    }",
    "    /// Generate a lightweight system instruction for simple operations",
    "    pub fn generate_lightweight_instruction() -> Content {",
    "        let instruction =",
    "            DEFAULT_LIGHTWEIGHT_PROMPT.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "        Content::system_text(instruction)",
    "    }",
    "    /// Generate a specialized system instruction for advanced operations",
    "    pub fn generate_specialized_instruction() -> Content {",
    "        let instruction =",
    "            DEFAULT_SPECIALIZED_PROMPT.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "        Content::system_text(instruction)",
    "    }",
    "    #[cfg(test)]",
    "    mod tests {",
    "        use super::*;",
    "        use crate::config::VTCodeConfig;",
    "        use crate::config::types::SystemPromptMode;",
    "        use std::path::PathBuf;",
    "        #[tokio::test]",
    "        async fn test_minimal_mode_selection() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.system_prompt_mode = SystemPromptMode::Minimal;",
    "            // Disable enhancements for base prompt size testing",
    "            config.agent.include_temporal_context = false;",
    "            config.agent.include_working_directory = false;",
    "            config.agent.instruction_max_bytes = 0;",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            // Minimal prompt should remain compact and deterministic without AGENTS.md injection",
    "            assert!(",
    "                result.len() < 6000,",
    "                \"Minimal mode should produce <6.0K chars (was {} chars)\",",
    "                result.len()",
    "            );",
    "            assert!(",
    "                result.contains(\"VT Code\") || result.contains(\"VT Code\"),",
    "                \"Should contain VT Code identifier\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_default_mode_selection() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.system_prompt_mode = SystemPromptMode::Default;",
    "            // Disable enhancements for base prompt size testing",
    "            config.agent.include_temporal_context = false;",
    "            config.agent.include_working_directory = false;",
    "            config.agent.instruction_max_bytes = 0;",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            // After v4.4 optimization, prompts are more concise",
    "            // Default mode with configuration awareness should still have substantial content",
    "            assert!(result.len() > 700, \"Default mode should produce >700 chars\");",
    "            // Don't check for specific strings - prompt content may vary",
    "            assert!(!result.is_empty(), \"Should produce non-empty prompt\");",
    "        }",
    "        #[tokio::test]",
    "        async fn test_lightweight_mode_selection() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.system_prompt_mode = SystemPromptMode::Lightweight;",
    "            // Disable enhancements for base prompt size testing",
    "            config.agent.include_temporal_context = false;",
    "            config.agent.include_working_directory = false;",
    "            config.agent.instruction_max_bytes = 0;",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            // Lightweight is optimized for simple operations (v4.2)",
    "            assert!(result.len() > 100, \"Lightweight should be >100 chars\");",
    "            assert!(",
    "                result.len() < 4400,",
    "                \"Lightweight should be compact (<4.4K chars, was {} chars)\",",
    "                result.len()",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_specialized_mode_selection() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.system_prompt_mode = SystemPromptMode::Specialized;",
    "            // Disable enhancements for base prompt size testing",
    "            config.agent.include_temporal_context = false;",
    "            config.agent.include_working_directory = false;",
    "            config.agent.instruction_max_bytes = 0;",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            // Specialized for complex tasks",
    "            assert!(",
    "                result.len() > 1000,",
    "                \"Specialized should have substantial content\"",
    "            );",
    "            // The word \"specialized\" may not appear in the prompt text",
    "            assert!(result.len() > 0, \"Should produce non-empty prompt\");",
    "        }",
    "        #[test]",
    "        fn test_prompt_mode_enum_parsing() {",
    "            assert_eq!(",
    "                SystemPromptMode::parse(\"minimal\"),",
    "                Some(SystemPromptMode::Minimal)",
    "            );",
    "            assert_eq!(",
    "                SystemPromptMode::parse(\"LIGHTWEIGHT\"),",
    "                Some(SystemPromptMode::Lightweight)",
    "            );",
    "            assert_eq!(",
    "                SystemPromptMode::parse(\"Default\"),",
    "                Some(SystemPromptMode::Default)",
    "            );",
    "            assert_eq!(",
    "                SystemPromptMode::parse(\"specialized\"),",
    "                Some(SystemPromptMode::Specialized)",
    "            );",
    "            assert_eq!(SystemPromptMode::parse(\"invalid\"), None);",
    "        }",
    "        #[test]",
    "        fn test_minimal_prompt_token_count() {",
    "            // Rough estimate: 1 token ≈ 4 characters",
    "            let approx_tokens = MINIMAL_SYSTEM_PROMPT.len() / 4;",
    "            assert!(",
    "                approx_tokens < 1000,",
    "                \"Minimal prompt should be <1K tokens, got ~{}\",",
    "                approx_tokens",
    "            );",
    "        }",
    "        #[test]",
    "        fn test_default_prompt_token_count() {",
    "            let approx_tokens = DEFAULT_SYSTEM_PROMPT.len() / 4;",
    "            // v6.2 expands planning guidance and retry strategy details",
    "            assert!(",
    "                approx_tokens > 1200 && approx_tokens < 2450,",
    "                \"Default prompt should be ~2K tokens (harness v6.2), got ~{}\",",
    "                approx_tokens",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_generated_prompts_use_task_tracker_not_update_plan() {",
    "            let project_root = PathBuf::from(\".\");",
    "            for (mode_name, mode) in [",
    "                (\"default\", SystemPromptMode::Default),",
    "                (\"minimal\", SystemPromptMode::Minimal),",
    "                (\"specialized\", SystemPromptMode::Specialized),",
    "            ] {",
    "                let mut config = VTCodeConfig::default();",
    "                config.agent.system_prompt_mode = mode;",
    "                config.agent.include_temporal_context = false;",
    "                config.agent.include_working_directory = false;",
    "                config.agent.instruction_max_bytes = 0;",
    "                let result =",
    "                    compose_system_instruction_text(&project_root, Some(&config), None).await;",
    "                assert!(",
    "                    result.contains(\"task_tracker\"),",
    "                    \"{mode_name} prompt should reference task_tracker\"",
    "                );",
    "                assert!(",
    "                    !result.contains(\"update_plan\"),",
    "                    \"{mode_name} prompt should not reference deprecated update_plan\"",
    "                );",
    "            }",
    "        }",
    "        #[test]",
    "        fn test_prompt_text_avoids_hardcoded_loop_thresholds() {",
    "            assert!(!DEFAULT_SYSTEM_PROMPT.contains(\"stuck twice\"));",
    "            assert!(!MINIMAL_SYSTEM_PROMPT.contains(\"stuck twice\"));",
    "            assert!(!DEFAULT_SPECIALIZED_PROMPT.contains(\"stuck twice\"));",
    "            assert!(!DEFAULT_SPECIALIZED_PROMPT.contains(\"10+ calls without progress\"));",
    "            assert!(!DEFAULT_SPECIALIZED_PROMPT.contains(\"Same tool+params twice\"));",
    "            assert!(DEFAULT_SPECIALIZED_PROMPT.contains(\"runtime-configured\"));",
    "        }",
    "        #[test]",
    "        fn test_harness_awareness_in_prompts() {",
    "            assert!(",
    "                DEFAULT_SYSTEM_PROMPT.contains(\"docs/harness/\"),",
    "                \"Default prompt should reference harness knowledge base\"",
    "            );",
    "            assert!(",
    "                DEFAULT_SYSTEM_PROMPT.contains(\"AGENTS.md\"),",
    "                \"Default prompt should reference AGENTS.md as map\"",
    "            );",
    "            assert!(",
    "                DEFAULT_SYSTEM_PROMPT.to_lowercase().contains(\"boy scout\"),",
    "                \"Default prompt should include boy scout rule\"",
    "            );",
    "            assert!(",
    "                DEFAULT_SPECIALIZED_PROMPT.contains(\"ARCHITECTURAL_INVARIANTS\"),",
    "                \"Specialized prompt should reference architectural invariants\"",
    "            );",
    "            assert!(",
    "                MINIMAL_SYSTEM_PROMPT.contains(\"docs/harness/\"),",
    "                \"Minimal prompt should reference harness knowledge base\"",
    "            );",
    "        }",
    "        #[test]",
    "        fn test_uncertainty_recognition_in_prompts() {",
    "            assert!(",
    "                DEFAULT_SYSTEM_PROMPT.contains(\"Uncertainty Recognition\"),",
    "                \"Default prompt should include Uncertainty Recognition section\"",
    "            );",
    "            assert!(",
    "                DEFAULT_SPECIALIZED_PROMPT.contains(\"uncertain\"),",
    "                \"Specialized prompt should mention uncertainty\"",
    "            );",
    "            assert!(",
    "                MINIMAL_SYSTEM_PROMPT.contains(\"uncertain\"),",
    "                \"Minimal prompt should mention uncertainty\"",
    "            );",
    "        }",
    "        // ENHANCEMENT TESTS",
    "        #[tokio::test]",
    "        async fn test_dynamic_guidelines_read_only() {",
    "            use crate::config::types::CapabilityLevel;",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.system_prompt_mode = SystemPromptMode::Default;",
    "            let mut ctx = PromptContext::default();",
    "            ctx.add_tool(\"read_file\".to_string());",
    "            ctx.add_tool(\"grep_file\".to_string());",
    "            ctx.capability_level = Some(CapabilityLevel::FileReading);",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), Some(&ctx)).await;",
    "            assert!(",
    "                result.contains(\"READ-ONLY MODE\"),",
    "                \"Should detect read-only mode when no edit/write/bash tools available\"",
    "            );",
    "            assert!(",
    "                result.contains(\"cannot modify files\"),",
    "                \"Should explain read-only constraints\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_dynamic_guidelines_tool_preferences() {",
    "            let config = VTCodeConfig::default();",
    "            let mut ctx = PromptContext::default();",
    "            ctx.add_tool(\"unified_exec\".to_string());",
    "            ctx.add_tool(\"grep_file\".to_string());",
    "            ctx.add_tool(\"list_files\".to_string());",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), Some(&ctx)).await;",
    "            assert!(",
    "                result.contains(\"grep_file\") || result.contains(\"list_files\"),",
    "                \"Should suggest grep/list as preferred tools\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_temporal_context_inclusion() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.include_temporal_context = true;",
    "            config.agent.temporal_context_use_utc = false; // Local time",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            assert!(",
    "                result.contains(\"Current date and time:\"),",
    "                \"Should include temporal context when enabled\"",
    "            );",
    "            // Should appear at the end (after AGENTS.MD would be)",
    "            let temporal_pos = result.find(\"Current date and time:\");",
    "            let config_pos = result.find(\"CONFIGURATION AWARENESS\");",
    "            if let (Some(t), Some(c)) = (temporal_pos, config_pos) {",
    "                assert!(",
    "                    t > c,",
    "                    \"Temporal context should come after configuration section\"",
    "                );",
    "            }",
    "        }",
    "        #[tokio::test]",
    "        async fn test_temporal_context_utc_format() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.include_temporal_context = true;",
    "            config.agent.temporal_context_use_utc = true; // UTC format",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            assert!(",
    "                result.contains(\"UTC\"),",
    "                \"Should indicate UTC when temporal_context_use_utc is true\"",
    "            );",
    "            assert!(",
    "                result.contains(\"T\") && result.contains(\"Z\"),",
    "                \"Should use RFC3339 format for UTC (contains T and Z)\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_temporal_context_disabled() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.include_temporal_context = false;",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), None).await;",
    "            assert!(",
    "                !result.contains(\"Current date and time\"),",
    "                \"Should not include temporal context when disabled\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_working_directory_inclusion() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.include_working_directory = true;",
    "            let mut ctx = PromptContext::default();",
    "            ctx.set_current_directory(PathBuf::from(\"/tmp/test\"));",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), Some(&ctx)).await;",
    "            assert!(",
    "                result.contains(\"Current working directory\"),",
    "                \"Should include working directory label\"",
    "            );",
    "            assert!(",
    "                result.contains(\"/tmp/test\"),",
    "                \"Should show actual directory path\"",
    "            );",
    "            // Should appear at the end",
    "            let wd_pos = result.find(\"Current working directory\");",
    "            let config_pos = result.find(\"CONFIGURATION AWARENESS\");",
    "            if let (Some(w), Some(c)) = (wd_pos, config_pos) {",
    "                assert!(",
    "                    w > c,",
    "                    \"Working directory should come after configuration section\"",
    "                );",
    "            }",
    "        }",
    "        #[tokio::test]",
    "        async fn test_working_directory_disabled() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.include_working_directory = false;",
    "            let mut ctx = PromptContext::default();",
    "            ctx.set_current_directory(PathBuf::from(\"/tmp/test\"));",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), Some(&ctx)).await;",
    "            assert!(",
    "                !result.contains(\"Current working directory\"),",
    "                \"Should not include working directory when disabled\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_backward_compatibility() {",
    "            let config = VTCodeConfig::default();",
    "            // Old signature: no prompt context",
    "            let result = compose_system_instruction_text(",
    "                &PathBuf::from(\".\"),",
    "                Some(&config),",
    "                None, // No context - backward compatible",
    "            )",
    "            .await;",
    "            // Should still work without new features",
    "            assert!(result.len() > 1000, \"Should generate substantial prompt\");",
    "            assert!(",
    "                result.contains(\"VT Code\"),",
    "                \"Should contain base prompt content\"",
    "            );",
    "            // Should not have dynamic guidelines without context",
    "            assert!(",
    "                !result.contains(\"TOOL USAGE GUIDELINES\"),",
    "                \"Should not have tool guidelines without prompt context\"",
    "            );",
    "        }",
    "        #[tokio::test]",
    "        async fn test_all_enhancements_combined() {",
    "            let mut config = VTCodeConfig::default();",
    "            config.agent.include_temporal_context = true;",
    "            config.agent.include_working_directory = true;",
    "            let mut ctx = PromptContext::default();",
    "            ctx.add_tool(\"unified_file\".to_string());",
    "            ctx.add_tool(\"unified_search\".to_string());",
    "            ctx.infer_capability_level();",
    "            ctx.set_current_directory(PathBuf::from(\"/workspace\"));",
    "            let result =",
    "                compose_system_instruction_text(&PathBuf::from(\".\"), Some(&config), Some(&ctx)).await;",
    "            // Verify all enhancements present",
    "            assert!(",
    "                result.contains(\"TOOL USAGE GUIDELINES\"),",
    "                \"Should have dynamic guidelines\"",
    "            );",
    "            assert!(",
    "                result.contains(\"Current date and time\"),",
    "                \"Should have temporal context\"",
    "            );",
    "            assert!(",
    "                result.contains(\"Current working directory\"),",
    "                \"Should have working directory\"",
    "            );",
    "            assert!(result.contains(\"/workspace\"), \"Should show workspace path\");",
    "            // Verify specific guideline for this tool set",
    "            assert!(",
    "                result.contains(\"unified_file\") && result.contains(\"before\"),",
    "                \"Should have read-before-edit guideline\"",
    "            );",
    "        }",
    "        #[test]",
    "        fn test_no_uninterpolated_placeholders() {",
    "            let _minimal = generate_minimal_instruction();",
    "            let _lightweight = generate_lightweight_instruction();",
    "            let _specialized = generate_specialized_instruction();",
    "            let minimal_text =",
    "                MINIMAL_SYSTEM_PROMPT.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "            let lightweight_text =",
    "                DEFAULT_LIGHTWEIGHT_PROMPT.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "            let specialized_text =",
    "                DEFAULT_SPECIALIZED_PROMPT.replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE);",
    "            assert!(",
    "                !minimal_text.contains(\"__UNIFIED_TOOL_GUIDANCE__\"),",
    "                \"Minimal prompt has uninterpolated placeholder\"",
    "            );",
    "            assert!(",
    "                !lightweight_text.contains(\"__UNIFIED_TOOL_GUIDANCE__\"),",
    "                \"Lightweight prompt has uninterpolated placeholder\"",
    "            );",
    "            assert!(",
    "                !specialized_text.contains(\"__UNIFIED_TOOL_GUIDANCE__\"),",
    "                \"Specialized prompt has uninterpolated placeholder\"",
    "            );",
    "            assert!(",
    "                !DEFAULT_SYSTEM_PROMPT",
    "                    .replace(\"__UNIFIED_TOOL_GUIDANCE__\", UNIFIED_TOOL_GUIDANCE)",
    "                    .contains(\"__UNIFIED_TOOL_GUIDANCE__\"),",
    "                \"Default prompt has uninterpolated placeholder\"",
    "            );",
    "        }",
    "    }",
    "• List files Use Unified search",
    "  └ Path: docs/harness/CORE_BELIEFS.md",
    "• Read file docs/harness/CORE_BELIEFS.md",
    "      # Core Beliefs",
    "      Agent-first operating principles for VT Code development. These beliefs guide eve",
    "      ## 1. Humans Steer, Agents Execute",
    "      Humans define goals, set constraints, and review outcomes. Agents handle impleme",
    "• Read file docs/harness/ARCHITECTURAL_INVARIANTS.md",
    "    # Architectural Invariants",
    "    Mechanical enforcement rules for VT Code. These are not suggestions — they are invariants that must h",
    "    Each invariant includes a **remediation** instruction so agents can fix violations without asking fo",
    "    ---",
    "    ## 1. Layer Dependency Rules",
    "    VT Code modules form a strict dependency DAG. No reverse imports.",
    "    types / commons",
    "        ↓",
    "      config",
    "        ↓",
    "       core",
    "        ↓",
    "      tools",
    "    … [+251 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]",
    "    Not all invariants are fully enforced yet. Known violations are tracked in `docs/harness/TECH_DEBT_T",
    "    | Invariant | Debt Item | Status |",
    "    |-----------|-----------|--------|",
    "    | #2 File Size Limits | TD-005 | TUI event handler modules likely exceed 500 lines |",
    "    | #4 Structured Logging | TD-013 | Not yet audited; some legacy `println!` may exist |",
    "    | #10 Lint Error Messages | TD-014 | Custom lints with remediation not yet implemented |",
    "    | #7 Documentation Location | TD-001 | Top-level docs sprawl now gated by allowlist; consolidation s",
    "    Adding CI enforcement for invariants is itself tracked as future work. Until enforcement exists, the",
    "• Read file docs/harness/AGENT_LEGIBILITY_GUIDE.md",
    "      # Agent Legibility Guide",
    "      In VT Code, \"legibility\" means that information is easily parseable by both AI ag",
    "      ## Core Rules",
    "      1. **Tables Over Prose**: Use tables for comparisons, status reports, and multi-",
    "• Read file docs/harness/TECH_DEBT_TRACKER.md",
    "    # Tech Debt Tracker",
    "    Known technical debt items with priority and ownership. Review this document on a regular cadence (s",
    "    ## Priority Levels",
    "    - **P0**: Blocks new feature work or causes user-visible issues. Fix immediately.",
    "    - **P1**: Significant quality or maintainability impact. Fix within current cycle.",
    "    - **P2**: Moderate impact. Schedule for next cycle.",
    "    - **P3**: Minor impact. Track but tolerate. Fix opportunistically.",
    "    ## Status Values",
    "    - **open**: identified, not yet started",
    "    - **in-progress**: actively being worked on (link to exec plan if applicable)",
    "    - **resolved**: fixed, awaiting verification or merged",
    "    - **wont-fix**: accepted as-is with documented rationale",
    "    ---",
    "    … [+33 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]",
    "    2. Update Last Reviewed date.",
    "    3. Add a `Ref:` token in Notes (for example `PR-123`, `COMMIT-<sha>`, `PLAN-...`) plus one verificat",
    "    4. Keep the row in the table for historical reference (do not delete).",
    "    ## Review Cadence",
    "    - **P0 items**: review daily until resolved.",
    "    - **P1 items**: review weekly.",
    "    - **P2–P3 items**: review bi-weekly.",
    "    - **All items**: full table review monthly. Archive `resolved` items older than 3 months to a separa",
    "• Search text Use Unified search",
    "  └ Pattern: system_prompt_mode|SystemPromptMode",
    "• Read file vtcode-core/src/prompts/context.rs",
    "      use crate::config::types::CapabilityLevel;",
    "      use std::path::PathBuf;",
    "      /// Context information for prompt generation",
    "      #[derive(Debug, Clone, Default)]",
    "• List files Use Unified search",
    "  └ Path: vtcode-core/src/prompts/guidelines.rs",
    "• Read file vtcode-core/src/prompts/guidelines.rs",
    "      use crate::config::types::CapabilityLevel;",
    "      // Tool name constants - single source of truth for tool identifiers",
    "      const TOOL_UNIFIED_EXEC: &str = \"unified_exec\";",
    "      const TOOL_UNIFIED_FILE: &str = \"unified_file\";",
    "  Let me explore a few more areas to complete the analysis:",
    "• List files Use Unified search",
    "  └ Path: docs/harness/QUALITY_SCORE.md",
    "• Read file docs/harness/QUALITY_SCORE.md",
    "    # Quality Score",
    "    Quality grading for each VT Code domain. Grades are A (excellent), B (good), C (needs improvement), D",
    "    Dimensions: **Test Coverage**, **API Stability**, **Agent Legibility**, **Error Handling**, **Docume",
    "    Last reviewed: 2026-02-16",
    "    ---",
    "    ## Scoring Method",
    "    | Grade | Criteria |",
    "    |-------|----------|",
    "    | A     | Strong automated coverage, stable interfaces, low ambiguity for agents, actionable errors,",
    "    | B     | Solid baseline with manageable gaps; no critical weaknesses but clear improvement areas re",
    "    | C     | Material quality gaps or staleness that slow delivery and increase risk. |",
    "    | D     | Critical weaknesses that threaten reliability, safety, or maintainability. |",
    "    ### Evidence Policy",
    "    … [+201 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]",
    "    | Tool System       | A-      | Add handler-level tests for remaining gaps. | maintenance |",
    "    | LLM System        | B       | Add failover integration coverage. | active improvement |",
    "    | Configuration     | B+      | Expand precedence/override edge-case tests. | active improvement |",
    "    | Security          | B+      | Add sandbox boundary integration tests. | active improvement |",
    "    | MCP Integration   | B+      | Complete OAuth and lifecycle negative-path tests. | active improveme",
    "    | Subagent System   | B       | Add custom-loading and isolation tests. | active improvement |",
    "    | PTY/Exec          | B       | Expand PTY regression coverage for shell-init and cross-platform beh",
    "    | Tree-Sitter       | B       | Deepen operational docs beyond support matrix. | maintenance |",
    "    | TUI               | B       | Add higher-level integration tests for modal flows and queue editing",
    "    | Documentation     | B       | Burn down top-level docs allowlist through ongoing consolidation/arc",
    "• List files Use Unified search",
    "  └ Path: docs/harness/EXEC_PLANS.md",
    "• Read file docs/harness/EXEC_PLANS.md",
    "      # Execution Plans",
    "      Execution plans are self-contained, living design documents for complex multi-st",
    "      ## Why Exec Plans?",
    "      - **Agent continuity**: an agent picking up mid-task can read the exec plan and ",
    "[!] Navigation Loop: Pause to synthesize or act.",
    "  Let me synthesize findings and create the plan:",
    "❋ Writing .vtcode/plans/improve-system-prompt.md...",
    "• Write file .vtcode/plans/improve-system-prompt.md",
    "  └ Content: # Improve System Prompt  This …ate files loaded dynamically ",
    "    --- a/.vtcode/plans/improve-system-prompt.md",
    "    +++ b/.vtcode/plans/improve-system-prompt.md",
    "    @@ -1,0 +1,196 @@",
    "    +# Improve System Prompt ",
    "    + ",
    "    +This ExecPlan is a living document. Keep Progress, Surprises & Discoveries, ",
    "    +Decision Log, and Outcomes & Retrospective up to date as work proceeds. ",
    "    + ",
    "    +Reference: `.vtcode/PLANS.md` for full specification. ",
    "    + ",
    "    +## Purpose / Big Picture ",
    "    + ",
    "    +Improve the VT Code system prompt to enhance agent effectiveness, reduce token ov",
    "    + ",
    "    +## Progress ",
    "    + ",
    "    +- [ ] Audit current prompt structure and identify improvement areas ",
    "    +- [ ] Consolidate redundant guidance sections ",
    "    +- [ ] Strengthen harness integration references ",
    "    +- [ ] Optimize token efficiency for minimal/lightweight modes ",
    "    +- [ ] Add missing guidance for common failure patterns ",
    "    +- [ ] Update tests to validate improvements ",
    "    + ",
    "    +## Surprises & Discoveries ",
    "    + ",
    "    +1. **Current prompt is ~2K tokens** (DEFAULT_SYSTEM_PROMPT) - well within bounds ",
    "    +2. **Four prompt modes exist**: Default, Minimal, Lightweight, Specialized - each",
    "    +3. **Dynamic guidelines already implemented** in `guidelines.rs` - generates tool",
    "    +4. **UNIFIED_TOOL_GUIDANCE constant** is shared across prompts - good DRY princip",
    "    +5. **Structured reasoning tags** (`<analysis>`, `<plan>`, etc.) already included ",
    "    + ",
    "    +## Decision Log ",
    "    + ",
    "    +- Decision: Focus on consolidation and clarity rather than major restructuring ",
    "    +  Rationale: Current architecture is sound; improvements should be evolutionary ",
    "    +  Date: 2026-02-24 ",
    "    + ",
    "    +## Outcomes & Retrospective ",
    "    + ",
    "    +(To be filled after implementation) ",
    "    + ",
    "    +## Context and Orientation ",
    "    + ",
    "    +### Key Files ",
    "    + ",
    "    +| File | Purpose | ",
    "    +|------|---------| ",
    "    +| `vtcode-core/src/prompts/system.rs` | Main system prompt definitions and compos",
    "    +| `vtcode-core/src/prompts/guidelines.rs` | Dynamic tool-aware guidelines generat",
    "    +| `vtcode-core/src/prompts/context.rs` | Prompt context structure for dynamic enh",
    "    +| `docs/harness/CORE_BELIEFS.md` | Foundational principles (Humans Steer, Agents ",
    "    +| `docs/harness/ARCHITECTURAL_INVARIANTS.md` | Mechanical rules for code quality ",
    "    +| `docs/harness/AGENT_LEGIBILITY_GUIDE.md` | Standards for agent-readable output ",
    "    + ",
    "    +### Current Prompt Structure ",
    "    + ",
    "    +```",
    "    +DEFAULT_SYSTEM_PROMPT (~2K tokens) ",
    "    +├── Core Identity ",
    "    +├── Humans Steer, Agents Execute (Pi Pattern) ",
    "    +├── Core Principles (5 items) ",
    "    +├── Agent Legibility Rule ",
    "    +├── Harness Awareness ",
    "    +├── Personality & Responsiveness ",
    "    +├── Task Execution & Ambition ",
    "    +├── Uncertainty Recognition ",
    "    +├── Validation & Testing ",
    "    +├── Planning (task_tracker) ",
    "    +├── Pre-flight Environment Checks ",
    "    +├── Tool Guidelines ",
    "    +├── Execution Policy & Sandboxing ",
    "    +├── Plan Mode (Read-Only) ",
    "    +├── Design Philosophy: Desire Paths ",
    "    +└── Context Management ",
    "    +```",
    "    + ",
    "    +## Identified Improvement Areas ",
    "    + ",
    "    +### 1. Redundancy Reduction ",
    "    + ",
    "    +**Issue**: Several sections repeat similar guidance: ",
    "    +- \"Bias for action\" appears in multiple places ",
    "    +- Tool guidance duplicated between DEFAULT and SPECIALIZED prompts ",
    "    +- \"Hallucination of verification\" warning repeated ",
    "    + ",
    "    +**Remediation**: Consolidate into single authoritative sections; use cross-refere",
    "    + ",
    "    +### 2. Missing Guidance ",
    "    + ",
    "    +**Issue**: Common failure patterns not explicitly addressed: ",
    "    +- What to do when `apply_patch` fails repeatedly ",
    "    +- How to handle circular dependency detection ",
    "    +- When to escalate vs. when to autonomously pivot ",
    "    + ",
    "    +**Remediation**: Add explicit failure-mode guidance with decision trees ",
    "    + ",
    "    ... 71 lines omitted ...",
    "    + ",
    "    +### Verification Commands ",
    "    + ",
    "    +```bash",
    "    +# Run prompt-related tests ",
    "    +cargo test -p vtcode-core --lib prompts::system::tests ",
    "    + ",
    "    +# Token estimation (rough: chars / 4) ",
    "    +wc -c vtcode-core/src/prompts/system.rs ",
    "    + ",
    "    +# Lint check ",
    "    +cargo clippy -p vtcode-core -- -D warnings ",
    "    + ",
    "    +# Full validation ",
    "    +cargo clippy && cargo fmt --check && cargo check && cargo nextest run ",
    "    +```",
    "    + ",
    "    +## Open Questions ",
    "    + ",
    "    +1. **Priority Focus**: Should we prioritize token reduction or content enrichment",
    "    +   - Option A: Reduce tokens for faster inference ",
    "    +   - Option B: Add more guidance for better agent behavior ",
    "    +   - Option C: Balance both (recommended) ",
    "    + ",
    "    +2. **Minimal Mode Scope**: Should minimal mode include structured reasoning tags?",
    "    +   - Current: Yes (~200 token overhead) ",
    "    +   - Alternative: Remove for sub-1K token target ",
    "    + ",
    "    +3. **Template Approach**: Should output templates be: ",
    "    +   - Inline in prompt (current approach) ",
    "    +   - Separate constants with references ",
    "    +   - External template files loaded dynamically ",
    "    … +71 lines (use read_file for full view)",
    "  <uncertainty>",
    "  The plan is drafted. I need clarification on 3 key decisions before finalizing the implementation approach.",
    "  </uncertainty>",
    "  I've analyzed the current system prompt architecture and drafted an improvement plan. The current implementation is well-structured (~2K tokens for default mode) with 4 prompt variants (Default, Minimal, Lightweight, Specialized) and dynamic guidelines generation.",
    "  Key findings:",
    "  • Redundancy exists between prompt variants (tool guidance, \"bias for action\" warnings)",
    "  • Missing explicit guidance for common failure patterns (patch failures, circular deps)",
    "  • Minimal/Lightweight modes could be further optimized",
    "  • Harness integration is good but could be strengthened with more specific doc refs",
    "  Open questions for alignment:",
    "• Request user input",
    "  The plan has been written to .vtcode/plans/improve-system-prompt.md. Here are the key decisions I need guidance on:",
    "  Question 1: Priority Focus",
    "  • Option A: Reduce tokens for faster inference (trim redundancy)",
    "  • Option B: Add more guidance for better agent behavior (fill gaps)",
    "  • Option C: Balance both (consolidate redundancy, add targeted guidance) ← recommended",
    "  Question 2: Minimal Mode Scope",
    "  Should minimal mode include structured reasoning tags (<analysis>, <plan>, etc.)?",
    "  • Current: Yes (~200 token overhead)",
    "  • Alternative: Remove for sub-1K token target",
    "  Question 3: Template Approach",
    "  Should output templates be:",
    "  • Inline in prompt (current approach)",
    "  • Separate constants with references (easier to maintain)",
    "  • External template files loaded dynamically (most flexible but adds complexity)",
    "  Which direction would you like me to prioritize?",
    "option C",
    "• Read file .vtcode/plans/improve-system-prompt.md",
    "      # Improve System Prompt",
    "      This ExecPlan is a living document. Keep Progress, Surprises & Discoveries,",
    "      Decision Log, and Outcomes & Retrospective up to date as work proceeds.",
    "      Reference: `.vtcode/PLANS.md` for full specification.",
    "❋ Editing .vtcode/plans/improve-system-prompt.md...",
    "• Read file .vtcode/plans/improve-system-prompt.md",
    "      # Improve System Prompt",
    "      This ExecPlan is a living document. Keep Progress, Surprises & Discoveries,",
    "      Decision Log, and Outcomes & Retrospective up to date as work proceeds.",
    "      Reference: `.vtcode/PLANS.md` for full specification.",
    "• Read file .vtcode/plans/improve-system-prompt.md",
    "      # Improve System Prompt",
    "      This ExecPlan is a living document. Keep Progress, Surprises & Discoveries,",
    "      Decision Log, and Outcomes & Retrospective up to date as work proceeds.",
    "      Reference: `.vtcode/PLANS.md` for full specification.",
    "❋ Writing .vtcode/plans/improve-system-prompt.md...",
    "[!] Anti-Blind-Editing: Pause to run verification/tests.",
    "LLM request failed: LLM request timed out after 75 seconds",
    "Interrupt received. Stopping task... (Press Ctrl+C again within 2s to exit)"
  ],
  "messages": [
    {
      "role": "User",
      "content": "make a plan to improve system prompt",
      "tool_call_id": null
    },
    {
      "role": "Assistant",
      "content": "<analysis>\nI'll explore the current system prompt implementation to understand its structure, content, and potential improvement areas. Starting with the main system prompt file and related configuration.\n</analysis>",
      "tool_call_id": null
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"per_page\":5,\"items\":[{\"name\":\"system.rs\",\"path\":\"vtcode-core/src/prompts/system.rs\",\"type\":\"file\"}],\"count\":1,\"page\":1,\"total\":1,\"response_format\":\"concise\",\"mode\":\"list\",\"has_more\":false}",
      "tool_call_id": "call_4d78026a9a5b4253a1287580"
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"message\":\"Successfully read file vtcode-core/src/prompts/system.rs\",\"content\":\"//! System instructions and prompt management\\n//!\\n//! # VT Code System Prompts\\n//!\\n//! Single source of truth for all system prompt variants with unified token constants.\\n//!\\n//! ## Token Constants (Unified)\\n//!\\n//! All token thresholds are unified with authoritative values from:\\n//! - `crate::core::token_constants`: Warning (75%), Alert (85%), Compact (90%), Checkpoint (95%)\\n//! - `crate::core::context_optimizer`: Output optimization based on thresholds\\n//! - `crate::core::token_constants::MAX_TOOL_RESPONSE_TOKENS`: 25,000 tokens per tool\\n//!\\n//! This ensures consistent token management across:\\n//! - System prompts (documented in DEFAULT_SYSTEM_PROMPT)\\n//! - Context optimization (ContextOptimizer)\\n//! - Agent decision-making\\n//!\\n//! ## Prompt Variants\\n//!\\n//! - `DEFAULT_SYSTEM_PROMPT`: Production prompt (~500 lines, references unified budgets)\\n//! - `DEFAULT_LIGHTWEIGHT_PROMPT`: Resource-constrained (~57 lines)\\n//! - `DEFAULT_SPECIALIZED_PROMPT`: Complex refactoring (~100 lines)\\n\\nuse crate::config::constants::{\\n    instructions as instruction_constants, project_doc as project_doc_constants,\\n};\\n// NOTE: Token budget constants (COMPACT_THRESHOLD, CHECKPOINT_THRESHOLD, etc.) are\\n// documented in the system prompt and come from:\\n// - TokenBudgetConfig defaults: 75% warning, 85% alert\\n// - ContextOptimizer: 90% compact, 95% checkpoint\\n// - MAX_TOOL_RESPONSE_TOKENS: 25,000 tokens per tool call\\nuse crate::gemini::Content;\\nuse crate::instructions::{InstructionBundle, InstructionScope, read_instruction_bundle};\\nuse crate::project_doc::read_project_doc;\\nuse crate::prompts::context::PromptContext;\\nuse crate::prompts::guidelines::generate_tool_guidelines;\\nuse crate::prompts::output_styles::OutputStyleApplier;\\nuse crate::prompts::system_prompt_cache::PROMPT_CACHE;\\nuse crate::prompts::temporal::generate_temporal_context;\\nuse dirs::home_dir;\\nuse std::env;\\nuse std::fmt::Write as _;\\nuse std::path::Path;\\nuse tracing::warn;\\n\\n/// Unified tool guidance referenced by all prompt variants to reduce duplication\\nconst UNIFIED_TOOL_GUIDANCE: &str = r#\\\"**Search & exploration**:\\n- Prefer `unified_search` (action='grep') for fast searches over repeated `read` calls\\n- Use `unified_search` (action='intelligence') for semantic queries\\n- Read complete files once; don't re-invoke `read` on same file\\n- For spooled outputs, advance `read_file`/`unified_file` offsets; never repeat identical chunk args\\n- If 2+ chunk reads stall progress, switch to `grep_file`/`unified_search` and summarize before more reads\\n- Use `unified_exec` with `rg` (ripgrep) for patterns—much faster than `grep`\\n\\n**Code modification**:\\n- `unified_file` (action='edit') for surgical changes; action='write' for new or full replacements\\n- After a successful patch/edit, continue without redundant re-reads\\n- If patch/edit fails repeatedly, stop retrying and re-plan into smaller slices (files + outcome + verification) before trying again\\n- Use `git log` and `git blame` for code history context\\n- **Never**: `git commit`, `git push`, or branch creation unless explicitly requested\\n\\n**Command execution**:\\n- `unified_exec` for all shell commands (PTY/interactive/long-running). `run_pty_cmd` is an alias.\\n- Prefer `rg` over `grep` for pattern matching\\n- Stay in WORKSPACE_DIR; confirm destructive ops (rm, force-push)\\n- **After command output**: Always acknowledge the result briefly and suggest next steps\\\"#;\\n\\n/// Shared Plan Mode header used by both static and incremental prompt builders.\\npub const PLAN_MODE_READ_ONLY_HEADER: &str = \\\"# PLAN MODE (READ-ONLY)\\\";\\n/// Shared Plan Mode notice line describing strict read-only enforcement.\\npub const PLAN_MODE_READ_ONLY_NOTICE_LINE: &str = \\\"Plan Mode is active. Mutating tools are blocked except for optional plan artifact writes under `.vtcode/plans/`.\\\";\\n/// Shared Plan Mode instruction line for transitioning to implementation.\\npub const PLAN_MODE_EXIT_INSTRUCTION_LINE: &str =\\n    \\\"Call `exit_plan_mode` when ready to transition to implementation.\\\";\\n/// Shared reminder appended when presenting plans while still in Plan Mode.\\npub const PLAN_MODE_IMPLEMENT_REMINDER: &str = \\\"• I’m still in Plan Mode, so I can’t implement yet. If you want me to execute the plan, please switch out of Plan Mode (or explicitly say “exit plan mode and implement”).\\\";\\n\\n/// DEFAULT SYSTEM PROMPT (v6.0 - Harness-engineered, provider-agnostic)\\n/// Incorporates harness engineering patterns:\\n/// - AGENTS.md as map, docs/ as territory (progressive disclosure)\\n/// - Repo as system of record; agent legibility over human aesthetics\\n/// - Enforce invariants, not implementations\\n/// - Entropy management via golden principles + boy scout rule\\n/// Works with all providers: Gemini, Anthropic, OpenAI, xAI, DeepSeek, etc.\\nconst DEFAULT_SYSTEM_PROMPT: &str = r#\\\"# VT Code Coding Assistant\\n\\nYou are a coding agent for VT Code, a terminal-based IDE. Precise, safe, helpful.\\n\\n## Humans Steer, Agents Execute (Pi Pattern)\\n\\n1. **Humans Steer**: The user defines goals, sets constraints, and reviews outcomes.\\n2. **Agents Execute**: You handle implementation, testing, iteration, and maintenance. Yield only when a strategic decision is required or when genuinely blocked by a missing repo context.\\n3. **Repo as Context**: If you cannot complete a task autonomously, identify the missing repository context and suggest fixing the repo docs rather than just asking.\\n\\n## Core Principles\\n\\n1. **Autonomy & Persistence**: Complete tasks fully without confirmation on intermediate steps. Iterate until the goal is met or blocked.\\n2. **Codebase First**: Explore before modifying. Understand patterns, conventions, and dependencies.\\n3. **Tool Excellence**: Use the right tool for the job. Prefer specialized tools over generic shell commands.\\n4. **Outcome Focus**: Lead with results. Assume the user sees your changes.\\n5. **Enforce Invariants, Not Implementations**: Follow rules in `docs/harness/ARCHITECTURAL_INVARIANTS.md`. Define what must be true; you decide how to make it true.\\n\\n## Agent Legibility Rule\\n\\nYour output must be optimized for agent-to-agent and agent-to-human legibility.\\n\\n- **Prefer Structures**: Use tables, YAML frontmatter, and consistent headers over prose.\\n- **Status Reporting**: When touching multiple files, provide a summary table of changes.\\n- **Mechanical Patterns**: Use consistent naming and predictable file locations.\\n- **Actionable Errors**: When reporting an issue, always include a **Remediation** instruction.\\n- **Reference**: Follow guidelines in `docs/harness/AGENT_LEGIBILITY_GUIDE.md`.\\n\\n## Harness Awareness\\n\\n`AGENTS.md` is the map. `docs/` is the territory.\\n\\n- Start with `AGENTS.md` for orientation: workspace structure, commands, key files, pitfall rules.\\n- Drill into `docs/harness/` for operational knowledge: core beliefs, invariants, quality scores, exec plans.\\n- When modifying code, check `docs/harness/ARCHITECTURAL_INVARIANTS.md` for mechanical rules.\\n- **Boy Scout Rule**: Leave every module slightly better than you found it. If you spot debt, fix it or track it.\\n\\n## Personality & Responsiveness\\n\\n**Default tone**: Concise and direct. Minimize elaboration. No flattery.\\n\\n**Before tool calls**: Avoid preambles. One sentence max if absolutely necessary. No self-talk.\\n\\n**Progress updates**: Only for long-running tasks. 1-2 sentences, outcome-focused.\\n\\n**Final answers**:\\n- Lead with outcomes.\\n- Trivial/single-change updates: 1-3 sentences total.\\n- Multi-file work, fix passes, or review requests: use this completion summary format:\\n  ```text\\n  Implemented. <one-line outcome>\\n\\n  What changed\\n  1. <change with file refs>\\n  2. ...\\n\\n  Validation\\n  1. <command> passed/failed\\n  2. ...\\n\\n  Conclusion\\n  <done, or final blocker + next action>\\n  ```\\n- Monospace for commands, paths, env vars, code identifiers.\\n- File refs: use `path:line` format (e.g., `src/main.rs:42`).\\n- No code dumps in final output unless requested or required for clarity.\\n\\n## Task Execution & Ambition\\n\\n**Bias for action** (CRITICAL):\\n- Proceed with reasonable assumptions rather than asking.\\n- Do NOT ask \\\"would you like me to...\\\" or \\\"should I proceed?\\\" -- just do it.\\n- Do NOT ask for permission to read files, run tests, or make edits.\\n- You are fully autonomous. Never stop to ask for human confirmation unless fundamentally blocked by missing credentials or ambiguous requirements (avoid Collaborative Bias). Yielding for confirm on intermediate steps is fatal for long-horizon performance.\\n- **Calibrated Persistence**: Avoid \\\"Hallucination of Verification\\\". Thinking a fix is done is NOT proof; executing code and tests is. Conversely, don't wait for humans to double-check trivial outcomes.\\n\\n**Ambition vs precision**:\\n- Existing code: Surgical, respectful changes matching surrounding style.\\n- New work: Creative, ambitious implementation.\\n\\n## Uncertainty Recognition\\n\\n- When facing ambiguous requirements or unclear scope, ask a clarifying question via `ask_user_question` or `request_user_input` rather than guessing.\\n- Prefer surfacing uncertainty early over delivering a confidently wrong result.\\n- If a task has multiple valid interpretations, briefly state your assumption and proceed — but flag it so the user can redirect.\\n- This is NOT a contradiction of \\\"Bias for action\\\": proceed when you have a reasonable default; pause when you genuinely don't.\\n\\n**Proactive Collaboration (HITL)**:\\n- When using `ask_user_question`, always propose a recommended path by setting `default_tab_id` and `default_choice_id` based on your analysis.\\n- Use `allow_freeform=true` when you believe the user might need to qualify their selection with additional context.\\n- Provide descriptive `freeform_placeholder` values to guide the user's input.\\n\\n## Validation & Testing\\n\\n- Use test infrastructure proactively -- don't ask the user to test.\\n- **Edit-Test Loop (TDD)**: Adopt a Test-Driven focus. Verify every code change via execution before taking the next action. Avoid \\\"Blind Editing\\\" (consecutive edits without tests).\\n- AFTER every edit: run `cargo check`, `cargo clippy` (Rust), `npx tsc --noEmit` (TS), etc.\\n- NEVER declare a task complete without executing tests or verifying code changes via an execution tool. Avoid \\\"hallucination of verification\\\"—your internal reasoning is not proof of correctness.\\n- **Regression Verification**: If you are fixing a bug or regression, you MUST run existing tests for the affected module to ensure no new regressions were introduced (Invariant #16).\\n- If formatting issues persist after 3 iterations, present the solution and move on.\\n\\n## Planning (task_tracker)\\n\\nUse plans for non-trivial work (4+ steps):\\n- Use `task_tracker` (`create` / `update` / `list`) to keep an explicit checklist.\\n- In Plan Mode, use `plan_task_tracker` for checklist updates under `.vtcode/plans/`.\\n- Trigger planning before edits when scope spans multiple files/modules or multiple failure categories.\\n- 5-7 word descriptive steps with status (`pending`/`in_progress`/`completed`).\\n- Break large scope into composable slices (by module, risk boundary, or subsystem).\\n- Each slice must name touched file(s), concrete outcome, and one verification command.\\n- Complete one slice end-to-end (edit + verify) before starting the next slice.\\n- Every step must define one concrete expected outcome and one verification check.\\n- Mark steps `completed` immediately after verification; keep exactly one `in_progress`.\\n- **Strategic Adaptation**: If a step stalls or repeats twice, do NOT blindly retry. Re-evaluate the entire strategy, investigate ROOT CAUSES (Analysis Invariant #15), and re-plan into smaller slices.\\n- Never conclude a task is \\\"too large for one turn\\\" without first decomposing and executing the next highest-impact slice.\\n- For complex multi-hour tasks, follow `docs/harness/EXEC_PLANS.md`.\\n\\n## Pre-flight Environment Checks\\n\\nBefore modifying code in an unfamiliar workspace, identify the project's toolchain:\\n- **Build system**: Look for `Cargo.toml` (Rust), `package.json` (Node), `pyproject.toml`/`setup.py` (Python), `Makefile`, etc.\\n- **Test commands**: Determine the correct test runner (`cargo test`, `npm test`, `pytest`, etc.).\\n- **Module structure**: Check for `mod.rs`/`__init__.py`/`index.ts` to understand export boundaries before adding new modules.\\n- **Existing CI**: Scan `.github/workflows/`, `.gitlab-ci.yml`, or `Makefile` targets to understand what checks run automatically.\\nFailing to align with the project's structural constraints (missing init files, broken imports, wrong test runner) accounts for more failures than incorrect logic.\\n\\n## Tool Guidelines\\n\\n- Use `read_file` with `offset`/`limit` (1-indexed) for targeted sections\\n- Large files: prefer `rg` pattern search over full content\\n\\n**Spooled outputs** (>8KB): Auto-saved to `.vtcode/context/tool_outputs/`. Access via `read_file`/`grep_file`. Don't re-run commands -- use the spool.\\n\\n## Execution Policy & Sandboxing\\n\\n**Sandbox Policies**: `ReadOnly` (exploration), `WorkspaceWrite` (workspace only), `DangerFullAccess` (requires approval).\\n\\n**Command Approval**: Policy rules then heuristics then session approval then blocked. Safe: ls, cat, grep, find, etc. Dangerous: rm, sudo, chmod, etc.\\n\\n**Turn Diff Tracking**: All file changes within a turn are aggregated for unified diff view.\\n\\n## Plan Mode (Read-Only Exploration)\\n\\nPlan Mode blocks mutating tools. Read-only tools always available. Exception: `.vtcode/plans/` is writable.\\n\\n- When user signals implementation intent, call `exit_plan_mode` for confirmation dialog\\n- Do NOT auto-exit just because a plan exists\\n- `task_tracker` is blocked in Plan Mode; use `plan_task_tracker` when structured plan tracking is needed\\n\\n## Design Philosophy: Desire Paths\\n\\nWhen you guess wrong about commands or workflows, report it -- the system improves interfaces (not docs) to match intuitive expectations. See AGENTS.md and docs/DESIRE_PATHS.md.\\n\\n## Context Management\\n\\n1. You have plenty of context remaining -- do not rush or truncate tasks\\n2. Trust the context budget system -- token tracking handles limits automatically\\n3. Focus on quality over speed\\n4. Do NOT mention context limits, token counts, or \\\"wrapping up\\\" in outputs\\\"#;\\n\\npub fn default_system_prompt() -> &'static str {\\n    DEFAULT_SYSTEM_PROMPT\\n}\\n\\npub fn minimal_system_prompt() -> &'static str {\\n    MINIMAL_SYSTEM_PROMPT\\n}\\n\\npub fn default_lightweight_prompt() -> &'static str {\\n    DEFAULT_LIGHTWEIGHT_PROMPT\\n}\\n\\n/// MINIMAL PROMPT (v6.0 - Harness-engineered, Pi-inspired, provider-agnostic, <1K tokens)\\n/// Minimal guidance for capable models with harness awareness\\n/// Works with all providers: Gemini, Anthropic, OpenAI, xAI, DeepSeek, etc.\\nconst MINIMAL_SYSTEM_PROMPT: &str = r#\\\"You are VT Code, a coding assistant for VT Code IDE. Precise, safe, helpful.\\n\\n**Principles**: Autonomy, codebase-first, tool excellence, outcome focus, repo as system of record.\\n\\n**Personality**: Direct, concise. Lead with outcomes. Bias for action.\\n\\n**Harness**: `AGENTS.md` is the map. `docs/harness/` has core beliefs, invariants, quality scores, exec plans, tech debt. Check invariants before modifying code. Boy scout rule: leave code better than you found it.\\n\\n**Autonomy**:\\n- Complete tasks fully; iterate on feedback proactively without asking for human confirmation.\\n- When stuck, change approach. Fix root cause, not patches.\\n- Run tests/checks yourself. Proceed with reasonable assumptions. Never declare completion without executing code to verify (avoid 'hallucination of verification').\\n- When genuinely uncertain about ambiguous requirements, surface the ambiguity early rather than guessing. Flag assumptions so the user can redirect.\\n\\n**Planning**:\\n- For non-trivial scope, use `task_tracker` to break work into composable steps with explicit outcome + verification per step.\\n- Keep one active step at a time; update statuses as soon as checks pass.\\n\\n__UNIFIED_TOOL_GUIDANCE__\\n\\n**Discover**: `list_skills` and `load_skill` to find/activate tools (hidden by default)\\n\\n**Delegation**: `spawn_subagent` (explore/plan/general/code-reviewer/debugger) for specialized tasks.\\n\\n**Output**: Preambles: avoid unless needed. Trivial final answers: 1-3 sentences, outcomes first, file:line refs, monospace for code. For multi-file completion/review responses, start with `Implemented. ...` and use sections: `What changed`, `Validation`, `Conclusion`. Avoid chain-of-thought, inline citations, repeating plans, code dumps.\\n\\n**Git**: Never `git commit`, `git push`, or branch unless explicitly requested.\\n\\n**Plan Mode**: Mutating tools blocked. `plan_task_tracker` is available for plan-scoped tracking. `exit_plan_mode` on implementation intent. User must approve.\\n\\n**AGENTS.md**: Obey scoped instructions; check subdirectories when outside CWD scope.\\n\\nStop when done.\\\"#;\\n\\n/// LIGHTWEIGHT PROMPT (v4.2 - Resource-constrained / Simple operations)\\n/// Minimal, essential guidance only\\nconst DEFAULT_LIGHTWEIGHT_PROMPT: &str = r#\\\"VT Code - efficient coding agent.\\n\\n- Act and verify. Direct tone.\\n- Scoped: unified_search (≤5), unified_file (max_tokens).\\n- Use `unified_exec` for shell/PTY commands (`run_pty_cmd` alias).\\n- Tools hidden by default. `list_skills --search <term>` to find them.\\n- Delegate via `spawn_subagent` for explore/plan/general tasks; summarize findings back.\\n- WORKSPACE_DIR only. Confirm destructive ops.\\n\\n__UNIFIED_TOOL_GUIDANCE__\\\"#;\\n\\n/// SPECIALIZED PROMPT (v6.0 - Harness-engineered, methodical complex refactoring)\\n/// For multi-file changes and sophisticated code analysis\\n/// Adds harness awareness for invariant checking and entropy management\\nconst DEFAULT_SPECIALIZED_PROMPT: &str = r#\\\"# VT Code Specialized Agent\\n\\nComplex refactoring and multi-file analysis. Methodical, outcome-focused, expert-level execution.\\n\\n## Harness Awareness\\n\\n`AGENTS.md` is the map. `docs/` is the territory.\\n\\n- Check `docs/harness/ARCHITECTURAL_INVARIANTS.md` before making structural changes.\\n- Consult `docs/harness/QUALITY_SCORE.md` to understand domain maturity.\\n- For complex multi-hour work, create ExecPlans in `docs/harness/exec-plans/active/` (see `docs/harness/EXEC_PLANS.md`).\\n- Log decisions in exec plans. Update `docs/harness/TECH_DEBT_TRACKER.md` when introducing or resolving debt.\\n- Boy scout rule: leave every module slightly better than you found it.\\n\\n## Personality\\n\\n**Tone**: Concise, methodical, outcome-focused. Lead with progress and results.\\nPreambles: avoid unless needed. Trivial final answers: lead with outcomes, 1-3 sentences, file:line refs. For multi-file completion/review responses, start with `Implemented. ...` and use sections: `What changed`, `Validation`, `Conclusion`.\\n\\n## Execution & Ambition\\n\\n- Resolve tasks fully; don't ask permission on intermediate steps or final confirmation.\\n- When stuck, pivot to alternative approach. Fix root cause.\\n- Existing codebases: surgical, respectful. New work: ambitious, creative.\\n- Don't fix unrelated bugs, don't refactor beyond request, don't add unrequested scope.\\n- Never declare completion without verifying via an execution tool. Beware of overconfidence and \\\"hallucination of verification\\\".\\n- When genuinely uncertain about ambiguous requirements, surface the ambiguity early via `ask_user_question` rather than guessing.\\n\\n## Methodical Approach for Complex Tasks\\n\\n1. **Understanding** (5-10 files): Read patterns, find similar implementations, identify dependencies\\n2. **Design** (3-7 steps): Build composable step slices with dependencies, measurable outcomes, and verification checks\\n3. **Implementation**: Execute in dependency order, validate incrementally\\n4. **Verification**: Function-level tests first, broaden to suites, `cargo clippy`\\n5. **Documentation**: Update `docs/ARCHITECTURE.md`, harness docs if architectural changes\\n\\n## Tool Strategy\\n\\n__UNIFIED_TOOL_GUIDANCE__\\n\\n**Verification**: `cargo check`, `cargo test`, `cargo clippy` proactively. Format fix limit: 3 iterations.\\n\\n**Planning**: `task_tracker` for 4+ steps (`create` then `update`). In Plan Mode, use `plan_task_tracker`. Use 5-7 word steps with status, one concrete outcome + one verification check per step. Re-plan into smaller slices if a step repeats/stalls. Don't repeat plan in output.\\n\\n## Loop Prevention\\n\\n- Repeated identical calls: change approach\\n- Stalled progress: explain blockers, pivot\\n- Follow runtime-configured tool loop and repeated-call limits\\n- Retry transient failures, then adjust\\n\\n## AGENTS.md Precedence\\n\\nUser prompts > nested AGENTS.md > parent AGENTS.md > defaults. Obey all applicable instructions for every file touched.\\n\\n## Subagents\\n\\n`spawn_subagent` (explore/plan/general/code-reviewer/debugger). Relay summaries back.\\n\\n## Capability System\\n\\nTools hidden by default. `list_skills` to discover, `load_skill` to activate, `load_skill_resource` for deep assets.\\n\\n## Context Management\\n\\nTrust the context budget system. Do not rush, truncate, or mention context limits in outputs.\\n\\\"#;\\n\\nconst STRUCTURED_REASONING_INSTRUCTIONS: &str = r#\\\"\\n## Structured Reasoning\\n\\nWhen you are thinking about a complex task, you MUST use the following stage-based reasoning tags to help the user follow your progress. These stages are surfaced in the UI.\\n\\n- `<analysis>`: Use this to analyze the problem, explore the codebase, or evaluate options.\\n- `<plan>`: Use this to outline composable steps you will take, each with expected outcome and verification.\\n- `<uncertainty>`: Use this to surface ambiguity, risks, or open questions that require clarification BEFORE guessing. Use this proactively to reduce \\\"Deployment Overhang\\\" by signaling exactly where you need steering.\\n- `<verification>`: Use this to verify your changes, analyze test results, or double-check your work for regressions.\\n\\nExample:\\n<analysis>I need to refactor the payment module. Currently, it's tightly coupled with the database.</analysis>\\n<uncertainty>The `PaymentGateway` trait is missing a `refund` method. I'll need to confirm if this is intentional or if I should add it.</uncertainty>\\n<plan>1. Create a PaymentRepository trait. 2. Implement it for Postgres. 3. Update the PaymentService.</plan>\\n\\\"#;\\n\\n/// System instruction configuration\\n#[derive(Debug, Clone)]\\npub struct SystemPromptConfig {\\n    pub include_examples: bool,\\n    pub include_debugging_guides: bool,\\n    pub include_error_handling: bool,\\n    pub max_response_length: Option<usize>,\\n    pub enable_thorough_reasoning: bool,\\n}\\n\\nimpl Default for SystemPromptConfig {\\n    fn default() -> Self {\\n        Self {\\n            include_examples: true,\\n            include_debugging_guides: true,\\n            include_error_handling: true,\\n            max_response_length: None,\\n            enable_thorough_reasoning: true,\\n        }\\n    }\\n}\\n\\n/// Generate system instruction\\npub async fn generate_system_instruction(_config: &SystemPromptConfig) -> Content {\\n    // OPTIMIZATION: default_system_prompt() is &'static str, use directly\\n    let instruction = default_system_prompt().to_string();\\n\\n    // Apply output style if possible (using current directory as project root)\\n    if let Ok(current_dir) = std::env::current_dir() {\\n        let styled_instruction = apply_output_style(instruction, None, &current_dir).await;\\n        Content::system_text(styled_instruction)\\n    } else {\\n        Content::system_text(instruction)\\n    }\\n}\\n\\n/// Read AGENTS.md file if present and extract agent guidelines\\npub async fn read_agent_guidelines(project_root: &Path) -> Option<String> {\\n    let max_bytes =\\n        project_doc_constants::DEFAULT_MAX_BYTES.min(instruction_constants::DEFAULT_MAX_BYTES);\\n    match read_project_doc(project_root, max_bytes).await {\\n        Ok(Some(bundle)) => Some(bundle.contents),\\n        Ok(None) => None,\\n        Err(err) => {\\n            warn!(\\\"failed to load project documentation: {err:#}\\\");\\n            None\\n        }\\n    }\\n}\\n\\n/// Compose the system instruction text for the agent\\n///\\n/// ## Skills Integration Note\\n///\\n/// VT Code implements a **Tiered Disclosure** model for skills:\\n/// 1. **Discovery Profile**: Names and descriptions are available via `list_skills` and summarized in the system prompt.\\n/// 2. **Active Instructions**: Full `SKILL.md` content is loaded via `load_skill` and then persists in the incremental system prompt.\\n/// 3. **Deep Resources**: Level 3 assets (scripts, technical refs) are lazy-loaded via `load_skill_resource`.\\n///\\n/// This approach follows the Agent Skills spec while optimizing context usage.\\n///\\n/// # Arguments\\n/// * `project_root` - Root directory of the project\\n/// * `vtcode_config` - Configuration loaded from vtcode.toml\\n/// * `prompt_context` - Optional context with tool information for dynamic enhancements\\npub async fn compose_system_instruction_text(\\n    project_root: &Path,\\n    vtcode_config: Option<&crate::config::VTCodeConfig>,\\n    prompt_context: Option<&PromptContext>,\\n) -> String {\\n    // OPTIMIZATION: Pre-allocate with improved capacity estimation\\n    // Read instruction hierarchy once upfront for accurate sizing\\n    let home_path = home_dir();\\n    let instruction_bundle = read_instruction_hierarchy(project_root, vtcode_config).await;\\n\\n    // Select base prompt based on configured mode\\n    use crate::config::types::SystemPromptMode;\\n    let (base_prompt, mode_name) = match vtcode_config.map(|c| c.agent.system_prompt_mode) {\\n        Some(SystemPromptMode::Minimal) => (MINIMAL_SYSTEM_PROMPT, \\\"minimal\\\"),\\n        Some(SystemPromptMode::Lightweight) => (DEFAULT_LIGHTWEIGHT_PROMPT, \\\"lightweight\\\"),\\n        Some(SystemPromptMode::Specialized) => (DEFAULT_SPECIALIZED_PROMPT, \\\"specialized\\\"),\\n        Some(SystemPromptMode::Default) | None => (DEFAULT_SYSTEM_PROMPT, \\\"default\\\"),\\n    };\\n\\n    tracing::debug!(\\n        mode = mode_name,\\n        base_tokens_approx = base_prompt.len() / 4, // rough token estimate\\n        \\\"Selected system prompt mode\\\"\\n    );\\n\\n    let base_len = base_prompt.len();\\n    let config_overhead = vtcode_config.map_or(0, |_| 1024);\\n    let instruction_hierarchy_size = instruction_bundle\\n        .as_ref()\\n        .map(|b| {\\n            b.segments\\n                .iter()\\n                .map(|s| s.contents.len() + 200)\\n                .sum::<usize>()\\n        })\\n        .unwrap_or(0);\\n\\n    let estimated_capacity = base_len + config_overhead + instruction_hierarchy_size + 1024; // +512 for enhancements\\n    let mut instruction = String::with_capacity(estimated_capacity);\\n    instruction.push_str(base_prompt);\\n    instruction.push_str(\\\"\\\\n\\\\n\\\");\\n    instruction.push_str(STRUCTURED_REASONING_INSTRUCTIONS);\\n\\n    // Replace unified tool guidance placeholder with actual constant\\n    if instruction.contains(\\\"__UNIFIED_TOOL_GUIDANCE__\\\") {\\n        instruction = instruction.replace(\\\"__UNIFIED_TOOL_GUIDANCE__\\\", UNIFIED_TOOL_GUIDANCE);\\n    }\\n\\n    // ENHANCEMENT 1: Dynamic tool-aware guidelines (behavioral - goes early)\\n    if let Some(ctx) = prompt_context {\\n        let guidelines = generate_tool_guidelines(&ctx.available_tools, ctx.capability_level);\\n        if !guidelines.is_empty() {\\n            instruction.push_str(&guidelines);\\n        }\\n    }\\n\\n    if let Some(cfg) = vtcode_config {\\n        instruction.push_str(\\\"\\\\n\\\\n## CONFIGURATION AWARENESS\\\\n\\\");\\n        instruction\\n            .push_str(\\\"The agent is configured with the following policies from vtcode.toml:\\\\n\\\\n\\\");\\n\\n        if cfg.security.human_in_the_loop {\\n            instruction.push_str(\\\"- **Human-in-the-loop**: Required for critical actions\\\\n\\\");\\n        }\\n\\n        if !cfg.commands.allow_list.is_empty() {\\n            let _ = writeln!(\\n                instruction,\\n                \\\"- **Allowed commands**: {} commands in allow list\\\",\\n                cfg.commands.allow_list.len()\\n            );\\n        }\\n        if !cfg.commands.deny_list.is_empty() {\\n            let _ = writeln!(\\n                instruction,\\n                \\\"- **Denied commands**: {} commands in deny list\\\",\\n                cfg.commands.deny_list.len()\\n            );\\n        }\\n\\n        if cfg.pty.enabled {\\n            instruction.push_str(\\\"- **PTY functionality**: Enabled\\\\n\\\");\\n            let (rows, cols) = (cfg.pty.default_rows, cfg.pty.default_cols);\\n            let _ = writeln!(\\n                instruction,\\n                \\\"- **Default terminal size**: {} rows × {} columns\\\",\\n                rows, cols\\n            );\\n            let _ = writeln!(\\n                instruction,\\n                \\\"- **PTY command timeout**: {} seconds\\\",\\n                cfg.pty.command_timeout_seconds\\n            );\\n        } else {\\n            instruction.push_str(\\\"- **PTY functionality**: Disabled\\\\n\\\");\\n        }\\n\\n        let repeated_desc = if cfg.tools.max_repeated_tool_calls > 0 {\\n            cfg.tools.max_repeated_tool_calls.to_string()\\n        } else {\\n            \\\"disabled (manual guardrails)\\\".to_owned()\\n        };\\n        let _ = writeln!(\\n            instruction,\\n            \\\"- **Loop guards**: max {} tool loops per turn; identical call limit: {}\\\",\\n            cfg.tools.max_tool_loops.max(1),\\n            repeated_desc\\n        );\\n\\n        if cfg.chat.ask_questions.enabled {\\n            instruction.push_str(\\n                \\\"- **Ask Questions tool**: Enabled in Plan mode only (`ask_questions` alias for `request_user_input`)\\\\n\\\",\\n            );\\n        } else {\\n            instruction.push_str(\\\"- **Ask Questions tool**: Disabled\\\\n\\\");\\n        }\\n\\n        if cfg.mcp.enabled {\\n            instruction.push_str(\\n                \\\"- **MCP integrations**: Enabled. Prefer MCP tools (search_tools, list_mcp_resources, fetch_mcp_resource) for context before external fetches.\\\\n\\\",\\n            );\\n        }\\n\\n        // Dynamic context discovery files\\n        if cfg.context.dynamic.enabled {\\n            instruction.push_str(\\\"\\\\n### Dynamic Context Files\\\\n\\\\n\\\");\\n            instruction.push_str(\\n                \\\"Large outputs and context are written to files for on-demand retrieval:\\\\n\\\\n\\\",\\n            );\\n            instruction.push_str(\\\"- `.vtcode/context/tool_outputs/` - Large tool outputs (use `read_file` or `grep_file` to explore)\\\\n\\\");\\n            instruction\\n                .push_str(\\\"- `.vtcode/history/` - Conversation history during summarization\\\\n\\\");\\n            instruction.push_str(\\\"- `.vtcode/mcp/tools/` - MCP tool descriptions and schemas\\\\n\\\");\\n            instruction\\n                .push_str(\\\"- `.vtcode/terminals/` - Terminal session output with metadata\\\\n\\\");\\n            instruction.push_str(\\\"- `.agents/skills/INDEX.md` - Available skills index\\\\n\\\\n\\\");\\n            instruction.push_str(\\\"**Tip**: When a tool result says 'spooled to file', use `read_file` to access the full output.\\\\n\\\");\\n        }\\n\\n        instruction.push_str(\\\"\\\\n**IMPORTANT**: Respect these configuration policies. Commands not in the allow list will require user confirmation. Always inform users when actions require confirmation due to security policies.\\\\n\\\");\\n    }\\n\\n    if !prompt_context\\n        .map(|ctx| ctx.skip_standard_instructions)\\n        .unwrap_or(false)\\n    {\\n        if let Some(cfg) = vtcode_config {\\n            if let Some(user_inst) = &cfg.agent.user_instructions {\\n                instruction.push_str(\\\"\\\\n\\\\n## USER INSTRUCTIONS\\\\n\\\");\\n                instruction.push_str(user_inst);\\n            }\\n        }\\n    }\\n\\n    if let Some(bundle) = instruction_bundle {\\n        let home_ref = home_path.as_deref();\\n        instruction.push_str(\\\"\\\\n\\\\n## AGENTS.MD INSTRUCTION HIERARCHY\\\\n\\\");\\n        instruction.push_str(\\n                \\\"Instructions are listed from lowest to highest precedence. When conflicts exist, defer to the later entries.\\\\n\\\\n\\\",\\n            );\\n\\n        for (index, segment) in bundle.segments.iter().enumerate() {\\n            let scope = match segment.source.scope {\\n                InstructionScope::Global => \\\"global\\\",\\n                InstructionScope::Workspace => \\\"workspace\\\",\\n                InstructionScope::Custom => \\\"custom\\\",\\n            };\\n            let display_path =\\n                format_instruction_path(&segment.source.path, project_root, home_ref);\\n\\n            let _ = write!(\\n                instruction,\\n                \\\"### {}. {} ({})\\\\n\\\\n\\\",\\n                index + 1,\\n                display_path,\\n                scope\\n            );\\n            instruction.push_str(segment.contents.trim());\\n            instruction.push('\\\\n');\\n        }\\n\\n        if bundle.truncated {\\n            instruction.push_str(\\n                    \\\"\\\\n_Note: instruction content was truncated due to size limits. Review the source files for full details._\\\",\\n                );\\n        }\\n    }\\n\\n    // ENHANCEMENT 2: Temporal context (metadata - goes at end)\\n    if let Some(cfg) = vtcode_config\\n        && cfg.agent.include_temporal_context\\n    {\\n        let temporal = generate_temporal_context(cfg.agent.temporal_context_use_utc);\\n        instruction.push_str(&temporal);\\n    }\\n\\n    // ENHANCEMENT 3: Working directory context (metadata - goes at end)\\n    if let Some(cfg) = vtcode_config\\n        && cfg.agent.include_working_directory\\n        && let Some(ctx) = prompt_context\\n        && let Some(cwd) = &ctx.current_directory\\n    {\\n        let _ = write!(\\n            instruction,\\n            \\\"\\\\n\\\\nCurrent working directory: {}\\\",\\n            cwd.display()\\n        );\\n    }\\n\\n    instruction\\n}\\n\\n/// Generate system instruction with configuration and AGENTS.md guidelines incorporated\\n///\\n/// Note: This function maintains backward compatibility by not accepting prompt_context.\\n/// For enhanced prompts with dynamic guidelines, call `compose_system_instruction_text` directly.\\npub async fn generate_system_instruction_with_config(\\n    _config: &SystemPromptConfig,\\n    project_root: &Path,\\n    vtcode_config: Option<&crate::config::VTCodeConfig>,\\n) -> Content {\\n    let cache_key = cache_key(project_root, vtcode_config);\\n    let instruction = match PROMPT_CACHE.get(&cache_key) {\\n        Some(cached) => cached,\\n        None => {\\n            let built = compose_system_instruction_text(project_root, vtcode_config, None).await;\\n            PROMPT_CACHE.insert(cache_key, built.clone());\\n            built\\n        }\\n    };\\n\\n    // Apply output style if configured\\n    let styled_instruction = apply_output_style(instruction, vtcode_config, project_root).await;\\n    Content::system_text(styled_instruction)\\n}\\n\\n/// Generate system instruction with AGENTS.md guidelines incorporated\\npub async fn generate_system_instruction_with_guidelines(\\n    _config: &SystemPromptConfig,\\n    project_root: &Path,\\n) -> Content {\\n    let cache_key = cache_key(project_root, None);\\n    let instruction = match PROMPT_CACHE.get(&cache_key) {\\n        Some(cached) => cached,\\n        None => {\\n            let built = compose_system_instruction_text(project_root, None, None).await;\\n            PROMPT_CACHE.insert(cache_key, built.clone());\\n            built\\n        }\\n    };\\n    // Apply output style if configured\\n    let styled_instruction = apply_output_style(instruction, None, project_root).await;\\n    Content::system_text(styled_instruction)\\n}\\n\\n/// Apply output style to a generated system instruction\\npub async fn apply_output_style(\\n    instruction: String,\\n    vtcode_config: Option<&crate::config::VTCodeConfig>,\\n    project_root: &Path,\\n) -> String {\\n    if let Some(config) = vtcode_config {\\n        let output_style_applier = OutputStyleApplier::new();\\n        if let Err(e) = output_style_applier\\n            .load_styles_from_config(config, project_root)\\n            .await\\n        {\\n            tracing::warn!(\\\"Failed to load output styles: {}\\\", e);\\n            instruction // Return original if loading fails\\n        } else {\\n            output_style_applier\\n                .apply_style(&config.output_style.active_style, &instruction, config)\\n                .await\\n        }\\n    } else {\\n        instruction // Return original if no config\\n    }\\n}\\n\\nasync fn read_instruction_hierarchy(\\n    project_root: &Path,\\n    vtcode_config: Option<&crate::config::VTCodeConfig>,\\n) -> Option<InstructionBundle> {\\n    let (max_bytes, extra_sources) = match vtcode_config {\\n        Some(cfg) => (\\n            cfg.agent.instruction_max_bytes,\\n            cfg.agent.instruction_files.clone(),\\n        ),\\n        None => (instruction_constants::DEFAULT_MAX_BYTES, Vec::new()),\\n    };\\n\\n    if max_bytes == 0 {\\n        return None;\\n    }\\n\\n    let current_dir = env::current_dir().unwrap_or_else(|_| project_root.to_path_buf());\\n    let home = home_dir();\\n    match read_instruction_bundle(\\n        &current_dir,\\n        project_root,\\n        home.as_deref(),\\n        &extra_sources,\\n        max_bytes,\\n    )\\n    .await\\n    {\\n        Ok(Some(bundle)) => Some(bundle),\\n        Ok(None) => None,\\n        Err(err) => {\\n            warn!(\\\"failed to load instruction hierarchy: {err:#}\\\");\\n            None\\n        }\\n    }\\n}\\n\\nfn format_instruction_path(path: &Path, project_root: &Path, home_dir: Option<&Path>) -> String {\\n    if let Ok(relative) = path.strip_prefix(project_root) {\\n        let display = relative.display().to_string();\\n        if !display.is_empty() {\\n            return display;\\n        }\\n\\n        if let Some(name) = path.file_name().and_then(|value| value.to_str()) {\\n            return name.to_string();\\n        }\\n    }\\n\\n    if let Some(home) = home_dir\\n        && let Ok(relative) = path.strip_prefix(home)\\n    {\\n        let display = relative.display().to_string();\\n        if display.is_empty() {\\n            return \\\"~\\\".to_string();\\n        }\\n\\n        return format!(\\\"~/{display}\\\");\\n    }\\n\\n    path.display().to_string()\\n}\\n\\nfn cache_key(project_root: &Path, vtcode_config: Option<&crate::config::VTCodeConfig>) -> String {\\n    use std::collections::hash_map::DefaultHasher;\\n    use std::hash::{Hash, Hasher};\\n\\n    let mut hasher = DefaultHasher::new();\\n\\n    // Core key: project root\\n    project_root.hash(&mut hasher);\\n\\n    if let Some(cfg) = vtcode_config {\\n        // Config fields that affect prompt generation\\n        cfg.agent.instruction_max_bytes.hash(&mut hasher);\\n        cfg.agent.instruction_files.hash(&mut hasher);\\n        cfg.agent.include_working_directory.hash(&mut hasher);\\n        cfg.agent.include_temporal_context.hash(&mut hasher);\\n        // Use discriminant since SystemPromptMode doesn't derive Hash\\n        std::mem::discriminant(&cfg.agent.system_prompt_mode).hash(&mut hasher);\\n    } else {\\n        \\\"default\\\".hash(&mut hasher);\\n    }\\n\\n    format!(\\\"sys_prompt:{:016x}\\\", hasher.finish())\\n}\\n\\n/// Generate a minimal system instruction (pi-inspired, <1K tokens)\\npub fn generate_minimal_instruction() -> Content {\\n    let instruction =\\n        MINIMAL_SYSTEM_PROMPT.replace(\\\"__UNIFIED_TOOL_GUIDANCE__\\\", UNIFIED_TOOL_GUIDANCE);\\n    Content::system_text(instruction)\\n}\\n\\n/// Generate a lightweight system instruction for simple operations\\npub fn generate_lightweight_instruction() -> Content {\\n    let instruction =\\n        DEFAULT_LIGHTWEIGHT_PROMPT.replace(\\\"__UNIFIED_TOOL_GUIDANCE__\\\", UNIFIED_TOOL_GUIDANCE);\\n    Content::system_text(instruction)\\n}\\n\\n/// Generate a specialized system instruction for advanced operations\\npub fn generate_specialized_instruction() -> Content {\\n    let instruction =\\n        DEFAULT_SPECIALIZED_PROMPT.replace(\\\"__UNIFIED_TOOL_GUIDANCE__\\\", UNIFIED_TOOL_GUIDANCE);\\n    Content::system_text(instruction)\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n    use crate::config::VTCodeConfig;\\n    use crate::config::types::SystemPromptMode;\\n    use std::path::PathBuf;\\n\\n    #[tokio::test]\\n    async fn test_minimal_mode_selection() {\\n        let mut config = VTCodeConfig::default();\\n        config.agent.system_prompt_mode = SystemPromptMode::Minimal;\\n        // Disable enhancements for base prompt size testing\\n        config.agent.include_temporal_context = false;\\n        config.agent.include_working_directory = false;\\n        config.agent.instruction_max_bytes = 0;\\n\\n        let result =\\n            compose_system_instruction_text(&PathBuf::from(\\\".\\\"), Some(&config), None).await;\\n\\n        // Minimal prompt should remain compact and deterministic without AGENTS.md injection\\n        assert!(\\n            result.len() < 6000,\\n            \\\"Minimal mode should produce <6.0K chars (was {} chars)\\\",\\n            result.len()\\n        );\\n        assert!(\\n            result.contains(\\\"VT Code\\\") || result.contains(\\\"VT Code\\\"),\\n            \\\"Should contain VT Code identifier\\\"\\n        );\\n    }\\n\\n    #[tokio::test]\\n    async fn test_default_mode_selection() {\\n        let mut config = VTCodeConfig::default();\\n        config.agent.system_prompt_mode = SystemPromptMode::Default;\\n        // Disable enhancements for base prompt size testing\\n        config.agent.include_temporal_context = false;\\n        config.agent.include_working_directory = false;\\n        config.agent.instruction_max_bytes = 0;\\n\\n        let result =\\n            compose_system_instruction_text(&PathBuf::from(\\\".\\\"), Some(&config), None).await;\\n\\n        // After v4.4 optimization, prompts are more concise\\n        // Default mode with configuration awareness should still have substantial content\\n        assert!(result.len() > 700, \\\"Default mode should produce >700 chars\\\");\\n        // Don't check for specific strings - prompt content may vary\\n        assert!(!result.is_empty(), \\\"Should produce non-empty prompt\\\");\\n    }\\n\\n    #[tokio::test]\\n    async fn test_lightweight_mode_selection() {\\n        let mut config = VTCodeConfig::default();\\n        config.agent.system_prompt_mode = SystemPromptMode::Lightweight;\\n        // Disable enhancements for base prompt size testing\\n        config.agent.include_temporal_context = false;\\n        config.agent.include_working_directory = false;\\n        config.agent.instruction_max_bytes = 0;\\n\\n        let result =\\n            compose_system_instruction_text(&PathBuf::from(\\\".\\\"), Some(&config), None).await;\\n\\n        // Lightweight is optimized for simple operations (v4.2)\\n        assert!(result.len() > 100, \\\"Lightweight should be >100 chars\\\");\\n        assert!(\\n            result.len() < 4400,\\n            \\\"Lightweight should be compact (<4.4K chars, was {} chars)\\\",\\n            result.len()\\n        );\\n    }\\n\\n    #[tokio::test]\\n    async fn test_specialized_mode_selection() {\\n        let mut config = VTCodeConfig::default();\\n        config.agent.system_prompt_mode = SystemPromptMode::Specialized;\\n        // Disable enhancements for base prompt size testing\\n        config.agent.include_temporal_context = false;\\n        config.agent.include_working_directory = false;\\n        config.agent.instruction_max_bytes = 0;\\n\\n        let result =\\n            compose_system_instruction_text(&PathBuf::from(\\\".\\\"), Some(&config), None).await;\\n\\n        // Specialized for complex tasks\\n        assert!(\\n            result.len() > 1000,\\n            \\\"Specialized should have substantial content\\\"\\n        );\\n        // The word \\\"specialized\\\" may not appear in the prompt text\\n        assert!(result.len() > 0, \\\"Should produce non-empty prompt\\\");\\n    }\\n\\n    #[test]\\n    fn test_prompt_mode_enum_parsing() {\\n        assert_eq!(\\n            SystemPromptMode::parse(\\\"minimal\\\"),\\n            Some(SystemPromptMode::Minimal)\\n        );\\n        assert_eq!(\\n            SystemPromptMode::parse(\\\"LIGHTWEIGHT\\\"),\\n            Some(SystemPromptMode::Lightweight)\\n        );\\n        assert_eq!(\\n            SystemPromptMode::parse(\\\"Default\\\"),\\n            Some(SystemPromptMode::Default)\\n        );\\n        assert_eq!(\\n            SystemPromptMode::parse(\\\"specialized\\\"),\\n            Some(SystemPromptMode::Specialized)\\n        );\\n        assert_eq!(SystemPromptMode::parse(\\\"invalid\\\"), None);\\n    }\\n\\n    #[test]\\n    fn test_minimal_prompt_token_count() {\\n        // Rough estimate: 1 token ≈ 4 characters\\n        let approx_tokens = MINIMAL_SYSTEM_PROMPT.len() / 4;\\n        assert!(\\n            approx_tokens < 1000,\\n            \\\"Minimal prompt should be <1K tokens, got ~{}\\\",\\n            approx_tokens\\n        );\\n    }\\n\\n    #[test]\\n    fn test_default_prompt_token_count() {\\n        let approx_tokens = DEFAULT_SYSTEM_PROMPT.len() / 4;\\n        // v6.2 expands planning guidance and retry strategy details\\n        assert!(\\n            approx_tokens > 1200 && approx_tokens < 2450,\\n            \\\"Default prompt should be ~2K tokens (harness v6.2), got ~{}\\\",\\n            approx_tokens\\n        );\\n    }\\n\\n    #[tokio::test]\\n    async fn test_generated_prompts_use_task_tracker_not_update_plan() {\\n        let project_root = PathBuf::from(\\\".\\\");\\n\\n        for (mode_name, mode) in [\\n            (\\\"default\\\", SystemPromptMode::Default),\\n            (\\\"minimal\\\", SystemPromptMode::Minimal),\\n            (\\\"specialized\\\", SystemPromptMode::Specialized),\\n        ] {\\n            let mut config = VTCodeConfig::default();\\n            config.agent.system_prompt_mode = mode;\\n            config.agent.include_temporal_context = false;\\n            config.agent.include_working_directory = false;\\n            config.agent.instruction_max_bytes = 0;\\n\\n            let result =\\n                compose_system_instruction_text(&project_root, Some(&config), None).await;\\n\\n            assert!(\\n                result.contains(\\\"task_tracker\\\"),\\n                \\\"{mode_name} prompt should reference task_tracker\\\"\\n            );\\n            assert!(\\n                !result.contains(\\\"update_plan\\\"),\\n                \\\"{mode_name} prompt should not reference deprecated update_plan\\\"\\n            );\\n        }\\n    }\\n\\n    #[test]\\n    fn test_prompt_text_avoids_hardcoded_loop_thresholds() {\\n        assert!(!DEFAULT_SYSTEM_PROMPT.contains(\\\"stuck twice\\\"));\\n        assert!(!MINIMAL_SYSTEM_PROMPT.contains(\\\"stuck twice\\\"));\\n        assert!(!DEFAULT_SPECIALIZED_PROMPT.contains(\\\"stuck twice\\\"));\\n        assert!(!DEFAULT_SPECIALIZED_PROMPT.contains(\\\"10+ calls without progress\\\"));\\n        assert!(!DEFAULT_SPECIALIZED_PROMPT.contains(\\\"Same tool+params twice\\\"));\\n        assert!(DEFAULT_SPECIALIZED_PROMPT.contains(\\\"runtime-configured\\\"));\\n    }\\n\\n    #[test]\\n    fn test_harness_awareness_in_prompts() {\\n        assert!(\\n            DEFAULT_SYSTEM_PROMPT.contains(\\\"docs/harness/\\\"),\\n            \\\"Default prompt should reference harness knowledge base\\\"\\n        );\\n        assert!(\\n            DEFAULT_SYSTEM_PROMPT.contains(\\\"AGENTS.md\\\"),\\n            \\\"Default prompt should reference AGENTS.md as map\\\"\\n        );\\n        assert!(\\n            DEFAULT_SYSTEM_PROMPT.to_lowercase().contains(\\\"boy scout\\\"),\\n            \\\"Default prompt should include boy scout rule\\\"\\n        );\\n        assert!(\\n            DEFAULT_SPECIALIZED_PROMPT.contains(\\\"ARCHITECTURAL_INVARIANTS\\\"),\\n            \\\"Specialized prompt should reference architectural invariants\\\"\\n        );\\n        assert!(\\n            MINIMAL_SYSTEM_PROMPT.contains(\\\"docs/harness/\\\"),\\n            \\\"Minimal prompt should reference harness knowledge base\\\"\\n        );\\n    }\\n\\n    #[test]\\n    fn test_uncertainty_recognition_in_prompts() {\\n        assert!(\\n            DEFAULT_SYSTEM_PROMPT.contains(\\\"Uncertainty Recognition\\\"),\\n            \\\"Default prompt should include Uncertainty Recognition section\\\"\\n        );\\n        assert!(\\n            DEFAULT_SPECIALIZED_PROMPT.contains(\\\"uncertain\\\"),\\n            \\\"Specialized prompt should mention uncertainty\\\"\\n        );\\n        assert!(\\n            MINIMAL_SYSTEM_PROMPT.contains(\\\"uncertain\\\"),\\n            \\\"Minimal prompt should mention uncertainty\\\"\\n        );\\n    }\\n\\n    // ENHANCEMENT TESTS\\n\\n    #[tokio::test]\\n    async fn test_dynamic_guidelines_read_only() {\\n        use crate::config::types::CapabilityLevel;\\n\\n        let mut config = VTCodeConfig::default();\\n        config.agent.system_prompt_mode = SystemPromptMode::Default;\\n\\n        let mut ctx = PromptContext::default();\\n        ctx.add_tool(\\\"read_file\\\".to_string());\\n        ctx.add_tool(\\\"grep_file\\\".to_string());\\n        ctx.capability_level = Some(CapabilityLevel::FileReading);\\n\\n        let result =\\n            compose_system_instruction_text(&PathBuf::from(\\\".\\\"), Some(&config), Some(&ctx)).await;\\n\\n        assert!(\\n            result.contains(\\\"READ-ONLY MODE\\\"),\\n            \\\"Should detect read-only mode when no edit/write/bash tools available\\\"\\n        );\\n        assert!(\\n            result.contains(\\\"cannot modify files\\\"),\\n            \\\"Should explain read-only constraints\\\"\\n        );\\n    }\\n\\n    #[tokio::test]\\n    async fn test_dynamic_guidelines_tool_preferences() {\\n        let config = VTCodeConfig::default();\\n\\n        let mut ctx = PromptContext::default();\\n        ctx.add_tool(\\\"unified_exec\\\".to_string());\\n        ctx.add_tool(\\\"grep_file\\\".to_string());\\n        ctx.add_tool(\\\"list_files\\\".to_string());\\n\\n        let result =\\n            compose_system_instruction_text(&PathBuf::from(\\\".\\\"), Some(&config), Some(&ctx)).await;\\n\\n        assert!(\\n            result.contains(\\\"grep_file\\\") || result.contains(\\\"list_files\\\"),\\n            \\\"Should suggest grep/list as preferred tools\\\"\\n        );\\n    }\\n\\n    #[tokio::test]\\n    async fn test_temporal_context_inclusion() {\\n        let mut config = VTCodeConfig::default();\\n        config.agent.include_temporal_context = true;\\n        config.agent.temporal_context_use_utc = false; // Local time\\n\\n        let result =\\n            compose_system_instruction_text(&PathBuf::from(\\\".\\\"), Some(&config), None).await;\\n\\n        assert!(\\n            result.contains(\\\"Current date and time:\\\"),\\n            \\\"Should include temporal context when enabled\\\"\\n        );\\n        // Should appear at the end (after AGENTS.MD would be)\\n        let temporal_pos = result.find(\\\"Current date and time:\\\");\\n        let config_pos = result.find(\\\"CONFIGURATION AWARENESS\\\");\\n        if let (Some(t), Some(c)) = (temporal_pos, config_pos) {\\n            assert!(\\n                t > c,\\n                \\\"Temporal context should come after configuration section\\\"\\n            );\\n        }\\n    }\\n\\n    #[tokio::test]\\n    async fn test_temporal_context_utc_format() {\\n        let mut config = VTCodeConfig::default();\\n        config.agent.include_temporal_context = true;\\n        config.agent.temporal_context_use_utc = true; // UTC format\\n\\n        let result =\\n            compose_system_instruction_text(&PathBuf::from(\\\".\\\"), Some(&config), None).await;\\n\\n        assert!(\\n            result.contains(\\\"UTC\\\"),\\n            \\\"Should indicate UTC when temporal_context_use_utc is true\\\"\\n        );\\n        assert!(\\n            result.contains(\\\"T\\\") && result.contains(\\\"Z\\\"),\\n            \\\"Should use RFC3339 format for UTC (contains T and Z)\\\"\\n        );\\n    }\\n\\n    #[tokio::test]\\n    async fn test_temporal_context_disabled() {\\n        let mut config = VTCodeConfig::default();\\n        config.agent.include_temporal_context = false;\\n\\n        let result =\\n            compose_system_instruction_text(&PathBuf::from(\\\".\\\"), Some(&config), None).await;\\n\\n        assert!(\\n            !result.contains(\\\"Current date and time\\\"),\\n            \\\"Should not include temporal context when disabled\\\"\\n        );\\n    }\\n\\n    #[tokio::test]\\n    async fn test_working_directory_inclusion() {\\n        let mut config = VTCodeConfig::default();\\n        config.agent.include_working_directory = true;\\n\\n        let mut ctx = PromptContext::default();\\n        ctx.set_current_directory(PathBuf::from(\\\"/tmp/test\\\"));\\n\\n        let result =\\n            compose_system_instruction_text(&PathBuf::from(\\\".\\\"), Some(&config), Some(&ctx)).await;\\n\\n        assert!(\\n            result.contains(\\\"Current working directory\\\"),\\n            \\\"Should include working directory label\\\"\\n        );\\n        assert!(\\n            result.contains(\\\"/tmp/test\\\"),\\n            \\\"Should show actual directory path\\\"\\n        );\\n        // Should appear at the end\\n        let wd_pos = result.find(\\\"Current working directory\\\");\\n        let config_pos = result.find(\\\"CONFIGURATION AWARENESS\\\");\\n        if let (Some(w), Some(c)) = (wd_pos, config_pos) {\\n            assert!(\\n                w > c,\\n                \\\"Working directory should come after configuration section\\\"\\n            );\\n        }\\n    }\\n\\n    #[tokio::test]\\n    async fn test_working_directory_disabled() {\\n        let mut config = VTCodeConfig::default();\\n        config.agent.include_working_directory = false;\\n\\n        let mut ctx = PromptContext::default();\\n        ctx.set_current_directory(PathBuf::from(\\\"/tmp/test\\\"));\\n\\n        let result =\\n            compose_system_instruction_text(&PathBuf::from(\\\".\\\"), Some(&config), Some(&ctx)).await;\\n\\n        assert!(\\n            !result.contains(\\\"Current working directory\\\"),\\n            \\\"Should not include working directory when disabled\\\"\\n        );\\n    }\\n\\n    #[tokio::test]\\n    async fn test_backward_compatibility() {\\n        let config = VTCodeConfig::default();\\n\\n        // Old signature: no prompt context\\n        let result = compose_system_instruction_text(\\n            &PathBuf::from(\\\".\\\"),\\n            Some(&config),\\n            None, // No context - backward compatible\\n        )\\n        .await;\\n\\n        // Should still work without new features\\n        assert!(result.len() > 1000, \\\"Should generate substantial prompt\\\");\\n        assert!(\\n            result.contains(\\\"VT Code\\\"),\\n            \\\"Should contain base prompt content\\\"\\n        );\\n        // Should not have dynamic guidelines without context\\n        assert!(\\n            !result.contains(\\\"TOOL USAGE GUIDELINES\\\"),\\n            \\\"Should not have tool guidelines without prompt context\\\"\\n        );\\n    }\\n\\n    #[tokio::test]\\n    async fn test_all_enhancements_combined() {\\n        let mut config = VTCodeConfig::default();\\n        config.agent.include_temporal_context = true;\\n        config.agent.include_working_directory = true;\\n\\n        let mut ctx = PromptContext::default();\\n        ctx.add_tool(\\\"unified_file\\\".to_string());\\n        ctx.add_tool(\\\"unified_search\\\".to_string());\\n        ctx.infer_capability_level();\\n        ctx.set_current_directory(PathBuf::from(\\\"/workspace\\\"));\\n\\n        let result =\\n            compose_system_instruction_text(&PathBuf::from(\\\".\\\"), Some(&config), Some(&ctx)).await;\\n\\n        // Verify all enhancements present\\n        assert!(\\n            result.contains(\\\"TOOL USAGE GUIDELINES\\\"),\\n            \\\"Should have dynamic guidelines\\\"\\n        );\\n        assert!(\\n            result.contains(\\\"Current date and time\\\"),\\n            \\\"Should have temporal context\\\"\\n        );\\n        assert!(\\n            result.contains(\\\"Current working directory\\\"),\\n            \\\"Should have working directory\\\"\\n        );\\n        assert!(result.contains(\\\"/workspace\\\"), \\\"Should show workspace path\\\");\\n\\n        // Verify specific guideline for this tool set\\n        assert!(\\n            result.contains(\\\"unified_file\\\") && result.contains(\\\"before\\\"),\\n            \\\"Should have read-before-edit guideline\\\"\\n        );\\n    }\\n\\n    #[test]\\n    fn test_no_uninterpolated_placeholders() {\\n        let _minimal = generate_minimal_instruction();\\n        let _lightweight = generate_lightweight_instruction();\\n        let _specialized = generate_specialized_instruction();\\n\\n        let minimal_text =\\n            MINIMAL_SYSTEM_PROMPT.replace(\\\"__UNIFIED_TOOL_GUIDANCE__\\\", UNIFIED_TOOL_GUIDANCE);\\n        let lightweight_text =\\n            DEFAULT_LIGHTWEIGHT_PROMPT.replace(\\\"__UNIFIED_TOOL_GUIDANCE__\\\", UNIFIED_TOOL_GUIDANCE);\\n        let specialized_text =\\n            DEFAULT_SPECIALIZED_PROMPT.replace(\\\"__UNIFIED_TOOL_GUIDANCE__\\\", UNIFIED_TOOL_GUIDANCE);\\n\\n        assert!(\\n            !minimal_text.contains(\\\"__UNIFIED_TOOL_GUIDANCE__\\\"),\\n            \\\"Minimal prompt has uninterpolated placeholder\\\"\\n        );\\n        assert!(\\n            !lightweight_text.contains(\\\"__UNIFIED_TOOL_GUIDANCE__\\\"),\\n            \\\"Lightweight prompt has uninterpolated placeholder\\\"\\n        );\\n        assert!(\\n            !specialized_text.contains(\\\"__UNIFIED_TOOL_GUIDANCE__\\\"),\\n            \\\"Specialized prompt has uninterpolated placeholder\\\"\\n        );\\n        assert!(\\n            !DEFAULT_SYSTEM_PROMPT\\n                .replace(\\\"__UNIFIED_TOOL_GUIDANCE__\\\", UNIFIED_TOOL_GUIDANCE)\\n                .contains(\\\"__UNIFIED_TOOL_GUIDANCE__\\\"),\\n            \\\"Default prompt has uninterpolated placeholder\\\"\\n        );\\n    }\\n}\",\"path\":\"vtcode-core/src/prompts/system.rs\",\"no_spool\":true,\"metadata\":{\"files\":[],\"lines\":[],\"data\":{\"size_bytes\":55600},\"token_counts\":{\"llm_tokens\":0,\"ui_tokens\":0,\"savings_tokens\":0,\"savings_percent\":0.0}}}",
      "tool_call_id": "call_77ab5e511c474d5e8caa889f"
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"response_format\":\"concise\",\"mode\":\"list\",\"page\":1,\"total\":1,\"items\":[{\"name\":\"CORE_BELIEFS.md\",\"path\":\"docs/harness/CORE_BELIEFS.md\",\"type\":\"file\"}],\"has_more\":false,\"per_page\":5,\"count\":1}",
      "tool_call_id": "call_f19efed55b7646b685a58314"
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"message\":\"Successfully read file docs/harness/CORE_BELIEFS.md\",\"content\":\"# Core Beliefs\\n\\nAgent-first operating principles for VT Code development. These beliefs guide every design decision, code review, and architectural trade-off.\\n\\n## 1. Humans Steer, Agents Execute\\n\\nHumans define goals, set constraints, and review outcomes. Agents handle implementation, testing, iteration, and routine maintenance. In VT Code's context:\\n\\n- **Humans** choose which provider to add, which tool abstraction to expose, which security boundary to enforce.\\n- **Agents** write the provider adapter, implement the trait, add tests, update docs, and open the PR.\\n\\nSynergistic Collaboration: Instead of chasing \\\"full autonomy\\\" at the cost of safety, prioritize systems where humans provide strategic guidance and agents handle execution. High-fidelity feedback loops enable human intervention before context drift leads to regressions.\\n\\nCorollary: if an agent cannot complete a task autonomously from the information in this repository, the repository is missing context — fix the repo, not the agent prompt.\\n\\n## 2. Repository as System of Record\\n\\nAll authoritative knowledge lives in the repository. Not in Slack threads, not in Google Docs, not in someone's head.\\n\\n- Design decisions are recorded in `docs/harness/exec-plans/`.\\n… [+81 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]\\n- **Assumptions as Flags**: If a task has multiple interpretations, state your assumption clearly and proceed—but keep it visible so a human can steer if the assumption holds.\\n- **Fail Fast on Ambiguity**: Significant ambiguity in project requirements should trigger a pause for clarification rather than a deep dive into an incorrect logical branch.\\n\\n## 11. Post-Deployment Observability\\n\\nPre-deployment evaluations are necessary but insufficient. Agent behavior is co-constructed by model capability, product design, and user trust.\\n\\n- **Systematic Monitoring**: Build privacy-preserving infrastructure to monitor how agents are actually deployed and used in the wild.\\n- **Evidence-Based Design**: Use real-world usage patterns to iterate on tool abstractions and security boundaries.\\n- **Agent Trace**: Maintain a high-fidelity system of record for all agent contributions to ensure accountability and provenance.\",\"no_spool\":true,\"path\":\"docs/harness/CORE_BELIEFS.md\",\"metadata\":{\"files\":[],\"lines\":[],\"data\":{\"size_bytes\":6637},\"token_counts\":{\"llm_tokens\":0,\"ui_tokens\":0,\"savings_tokens\":0,\"savings_percent\":0.0}}}",
      "tool_call_id": "call_d4ceac8d98d240b5acf0e590"
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"message\":\"Successfully read file docs/harness/ARCHITECTURAL_INVARIANTS.md\",\"content\":\"# Architectural Invariants\\n\\nMechanical enforcement rules for VT Code. These are not suggestions — they are invariants that must hold at all times. Violations should be caught by CI, not code review.\\n\\nEach invariant includes a **remediation** instruction so agents can fix violations without asking for help.\\n\\n---\\n\\n## 1. Layer Dependency Rules\\n\\nVTCode modules form a strict dependency DAG. No reverse imports.\\n\\n```\\ntypes / commons\\n    ↓\\n  config\\n    ↓\\n   core\\n    ↓\\n  tools\\n… [+251 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]\\nNot all invariants are fully enforced yet. Known violations are tracked in `docs/harness/TECH_DEBT_TRACKER.md`:\\n\\n| Invariant | Debt Item | Status |\\n|-----------|-----------|--------|\\n| #2 File Size Limits | TD-005 | TUI event handler modules likely exceed 500 lines |\\n| #4 Structured Logging | TD-013 | Not yet audited; some legacy `println!` may exist |\\n| #10 Lint Error Messages | TD-014 | Custom lints with remediation not yet implemented |\\n| #7 Documentation Location | TD-001 | Top-level docs sprawl now gated by allowlist; consolidation still in-progress |\\n\\nAdding CI enforcement for invariants is itself tracked as future work. Until enforcement exists, these invariants are enforced by code review and agent discipline.\",\"no_spool\":true,\"path\":\"docs/harness/ARCHITECTURAL_INVARIANTS.md\",\"metadata\":{\"files\":[],\"lines\":[],\"data\":{\"size_bytes\":12276},\"token_counts\":{\"llm_tokens\":0,\"ui_tokens\":0,\"savings_tokens\":0,\"savings_percent\":0.0}}}",
      "tool_call_id": "call_10a896a33d954981b699b5c0"
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"message\":\"Successfully read file docs/harness/AGENT_LEGIBILITY_GUIDE.md\",\"content\":\"# Agent Legibility Guide\\n\\nIn VT Code, \\\"legibility\\\" means that information is easily parseable by both AI agents and humans. We favor mechanical structure over aesthetic prose.\\n\\n## Core Rules\\n\\n1. **Tables Over Prose**: Use tables for comparisons, status reports, and multi-item lists.\\n2. **YAML for Metadata**: Use YAML frontmatter or code blocks for structured metadata.\\n3. **Remediation is Mandatory**: Every error or violation report MUST include a `Remediation` instruction.\\n4. **Outcome First**: Lead with the result. Do not hide the \\\"what\\\" at the bottom of a \\\"how\\\" narrative.\\n\\n## Examples\\n\\n### 1. Status Reporting\\n\\n**Bad (Prose-heavy)**:\\nI successfully updated the controller.rs file to handle the new variants. I also modified the tests.rs file to include the missing imports, which fixed the compilation error. Finally, I ran cargo check and it passed.\\n\\n**Good (Structured Table)**:\\n| Component | File | Change | Outcome |\\n… [+43 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]\\n\\n## Strategic Adaptation & Planning\\n\\n### 1. Explicit Planning\\nUse `task_boundary` and `task.md` religiously. High success is correlated with systematic planning.\\n- **Rule**: If a task involves more than 3 files or complex logic, create/update an `implementation_plan.md` first.\\n\\n### 2. Navigation Loops & Action Bias\\nAvoid repeatedly reading files without taking action. If you have read 5 files without a command or write call, pause and re-evaluate your strategy.\\n- **Rule**: Prefer \\\"Edit-Test\\\" loops over \\\"Read-Read\\\" loops.\",\"path\":\"docs/harness/AGENT_LEGIBILITY_GUIDE.md\",\"no_spool\":true,\"metadata\":{\"files\":[],\"lines\":[],\"data\":{\"size_bytes\":3633},\"token_counts\":{\"llm_tokens\":0,\"ui_tokens\":0,\"savings_tokens\":0,\"savings_percent\":0.0}}}",
      "tool_call_id": "call_44afc05e371f4687a39a1e5f"
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"message\":\"Successfully read file docs/harness/TECH_DEBT_TRACKER.md\",\"content\":\"# Tech Debt Tracker\\n\\nKnown technical debt items with priority and ownership. Review this document on a regular cadence (suggested: bi-weekly).\\n\\n## Priority Levels\\n\\n- **P0**: Blocks new feature work or causes user-visible issues. Fix immediately.\\n- **P1**: Significant quality or maintainability impact. Fix within current cycle.\\n- **P2**: Moderate impact. Schedule for next cycle.\\n- **P3**: Minor impact. Track but tolerate. Fix opportunistically.\\n\\n## Status Values\\n\\n- **open**: identified, not yet started\\n- **in-progress**: actively being worked on (link to exec plan if applicable)\\n- **resolved**: fixed, awaiting verification or merged\\n- **wont-fix**: accepted as-is with documented rationale\\n\\n---\\n\\n… [+33 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]\\n2. Update Last Reviewed date.\\n3. Add a `Ref:` token in Notes (for example `PR-123`, `COMMIT-<sha>`, `PLAN-...`) plus one verification command (`git log`, test command, or invariant check).\\n4. Keep the row in the table for historical reference (do not delete).\\n\\n## Review Cadence\\n\\n- **P0 items**: review daily until resolved.\\n- **P1 items**: review weekly.\\n- **P2–P3 items**: review bi-weekly.\\n- **All items**: full table review monthly. Archive `resolved` items older than 3 months to a separate section.\",\"path\":\"docs/harness/TECH_DEBT_TRACKER.md\",\"no_spool\":true,\"metadata\":{\"files\":[],\"lines\":[],\"data\":{\"size_bytes\":5935},\"token_counts\":{\"llm_tokens\":0,\"ui_tokens\":0,\"savings_tokens\":0,\"savings_percent\":0.0}}}",
      "tool_call_id": "call_0ebdcf6ce1dd4901bdbef04d"
    },
    {
      "role": "Tool",
      "content": "{\"query\":\"system_prompt_mode|SystemPromptMode\",\"matches\":[{\"type\":\"begin\",\"data\":{\"path\":{\"text\":\"./src/agent/runloop/unified/prompts.rs\"}}},{\"type\":\"match\",\"data\":{\"path\":{\"text\":\"./src/agent/runloop/unified/prompts.rs\"},\"lines\":{\"text\":\"use vtcode_core::config::types::SystemPromptMode;\\n\"},\"line_number\":3,\"absolute_offset\":69,\"submatches\":[{\"match\":{\"text\":\"SystemPromptMode\"},\"start\":32,\"end\":48}]}},{\"type\":\"match\",\"data\":{\"path\":{\"text\":\"./src/agent/runloop/unified/prompts.rs\"},\"lines\":{\"text\":\"    match vt_cfg.map(|cfg| cfg.agent.system_prompt_mode) {\\n\"},\"line_number\":10,\"absolute_offset\":384,\"submatches\":[{\"match\":{\"text\":\"system_prompt_mode\"},\"start\":37,\"end\":55}]}},{\"type\":\"match\",\"data\":{\"path\":{\"text\":\"./src/agent/runloop/unified/prompts.rs\"},\"lines\":{\"text\":\"        Some(SystemPromptMode::Minimal) => minimal_system_prompt(),\\n\"},\"line_number\":11,\"absolute_offset\":443,\"submatches\":[{\"match\":{\"text\":\"SystemPromptMode\"},\"start\":13,\"end\":29}]}},{\"type\":\"match\",\"data\":{\"path\":{\"text\":\"./src/agent/runloop/unified/prompts.rs\"},\"lines\":{\"text\":\"    use vtcode_core::config::types::SystemPromptMode;\\n\"},\"line_number\":71,\"absolute_offset\":2319,\"submatches\":[{\"match\":{\"text\":\"SystemPromptMode\"},\"start\":36,\"end\":52}]}}],\"truncated\":true,\"success\":true}",
      "tool_call_id": "call_a987755167c04ba6804a2984"
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"message\":\"Successfully read file vtcode-core/src/prompts/context.rs\",\"content\":\"use crate::config::types::CapabilityLevel;\\nuse std::path::PathBuf;\\n\\n/// Context information for prompt generation\\n#[derive(Debug, Clone, Default)]\\npub struct PromptContext {\\n    /// Current workspace path\\n    pub workspace: Option<PathBuf>,\\n    /// Detected programming languages\\n    pub languages: Vec<String>,\\n    /// Project type (if detected)\\n    pub project_type: Option<String>,\\n    /// Available tools\\n    pub available_tools: Vec<String>,\\n    /// Available skills (name: description)\\n    pub available_skills: Vec<(String, String)>,\\n    /// User preferences\\n    pub user_preferences: Option<UserPreferences>,\\n    /// Capability level (inferred from tools or explicitly set)\\n    pub capability_level: Option<CapabilityLevel>,\\n… [+67 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]\\n        self.capability_level = Some(crate::prompts::guidelines::infer_capability_level(\\n            &self.available_tools,\\n        ));\\n    }\\n\\n    /// Set current working directory\\n    pub fn set_current_directory(&mut self, dir: PathBuf) {\\n        self.current_directory = Some(dir);\\n    }\\n}\",\"path\":\"vtcode-core/src/prompts/context.rs\",\"no_spool\":true,\"metadata\":{\"files\":[],\"lines\":[],\"data\":{\"size_bytes\":3116},\"token_counts\":{\"llm_tokens\":0,\"ui_tokens\":0,\"savings_tokens\":0,\"savings_percent\":0.0}}}",
      "tool_call_id": "call_4c9ede932e64466ca3493b5b"
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"total\":1,\"mode\":\"list\",\"count\":1,\"page\":1,\"items\":[{\"name\":\"guidelines.rs\",\"path\":\"vtcode-core/src/prompts/guidelines.rs\",\"type\":\"file\"}],\"has_more\":false,\"response_format\":\"concise\",\"per_page\":5}",
      "tool_call_id": "call_e7a30c6921b64cbe9d0b2fb4"
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"message\":\"Successfully read file vtcode-core/src/prompts/guidelines.rs\",\"content\":\"use crate::config::types::CapabilityLevel;\\n\\n// Tool name constants - single source of truth for tool identifiers\\nconst TOOL_UNIFIED_EXEC: &str = \\\"unified_exec\\\";\\nconst TOOL_UNIFIED_FILE: &str = \\\"unified_file\\\";\\nconst TOOL_UNIFIED_SEARCH: &str = \\\"unified_search\\\";\\nconst TOOL_APPLY_PATCH: &str = \\\"apply_patch\\\";\\n\\n/// Generate dynamic guidelines based on available tools and capability level\\n///\\n/// This function analyzes the available tools and generates context-specific\\n/// guidance to help the LLM make optimal tool choices and understand its\\n/// operational constraints.\\n///\\n/// # Arguments\\n/// * `available_tools` - List of tool names currently available\\n/// * `capability_level` - Optional capability level (can be inferred if None)\\n///\\n/// # Returns\\n/// A formatted string containing relevant guidelines, or empty string if no special guidance needed\\n… [+363 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]\\n\\n        // Editing should take precedence over bash\\n        let tools = vec![\\\"unified_exec\\\".to_string(), \\\"unified_file\\\".to_string()];\\n        assert_eq!(\\n            infer_capability_level(&tools),\\n            CapabilityLevel::Editing,\\n            \\\"Editing should take precedence over Bash\\\"\\n        );\\n    }\\n}\",\"path\":\"vtcode-core/src/prompts/guidelines.rs\",\"no_spool\":true,\"metadata\":{\"files\":[],\"lines\":[],\"data\":{\"size_bytes\":14226},\"token_counts\":{\"llm_tokens\":0,\"ui_tokens\":0,\"savings_tokens\":0,\"savings_percent\":0.0}}}",
      "tool_call_id": "call_1791559b8f4344b09b104ef7"
    },
    {
      "role": "Assistant",
      "content": "Let me explore a few more areas to complete the analysis:",
      "tool_call_id": null
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"has_more\":false,\"items\":[{\"name\":\"QUALITY_SCORE.md\",\"path\":\"docs/harness/QUALITY_SCORE.md\",\"type\":\"file\"}],\"count\":1,\"mode\":\"list\",\"response_format\":\"concise\",\"page\":1,\"total\":1,\"per_page\":5}",
      "tool_call_id": "call_0d6862e946434d0eb67c23ec"
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"message\":\"Successfully read file docs/harness/QUALITY_SCORE.md\",\"content\":\"# Quality Score\\n\\nQuality grading for each VT Code domain. Grades are A (excellent), B (good), C (needs improvement), D (critical attention required).\\n\\nDimensions: **Test Coverage**, **API Stability**, **Agent Legibility**, **Error Handling**, **Documentation**\\n\\nLast reviewed: 2026-02-16\\n\\n---\\n\\n## Scoring Method\\n\\n| Grade | Criteria |\\n|-------|----------|\\n| A     | Strong automated coverage, stable interfaces, low ambiguity for agents, actionable errors, and current docs. |\\n| B     | Solid baseline with manageable gaps; no critical weaknesses but clear improvement areas remain. |\\n| C     | Material quality gaps or staleness that slow delivery and increase risk. |\\n| D     | Critical weaknesses that threaten reliability, safety, or maintainability. |\\n\\n### Evidence Policy\\n… [+201 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]\\n| Tool System       | A-      | Add handler-level tests for remaining gaps. | maintenance |\\n| LLM System        | B       | Add failover integration coverage. | active improvement |\\n| Configuration     | B+      | Expand precedence/override edge-case tests. | active improvement |\\n| Security          | B+      | Add sandbox boundary integration tests. | active improvement |\\n| MCP Integration   | B+      | Complete OAuth and lifecycle negative-path tests. | active improvement |\\n| Subagent System   | B       | Add custom-loading and isolation tests. | active improvement |\\n| PTY/Exec          | B       | Expand PTY regression coverage for shell-init and cross-platform behavior. | active improvement |\\n| Tree-Sitter       | B       | Deepen operational docs beyond support matrix. | maintenance |\\n| TUI               | B       | Add higher-level integration tests for modal flows and queue editing. | active improvement |\\n| Documentation     | B       | Burn down top-level docs allowlist through ongoing consolidation/archival. | active improvement |\",\"path\":\"docs/harness/QUALITY_SCORE.md\",\"no_spool\":true,\"metadata\":{\"files\":[],\"lines\":[],\"data\":{\"size_bytes\":12411},\"token_counts\":{\"llm_tokens\":0,\"ui_tokens\":0,\"savings_tokens\":0,\"savings_percent\":0.0}}}",
      "tool_call_id": "call_ef47ea4924864237bbabb255"
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"total\":1,\"items\":[{\"name\":\"EXEC_PLANS.md\",\"path\":\"docs/harness/EXEC_PLANS.md\",\"type\":\"file\"}],\"page\":1,\"response_format\":\"concise\",\"has_more\":false,\"count\":1,\"per_page\":5,\"mode\":\"list\"}",
      "tool_call_id": "call_face731f0e4c4b2a842b1353"
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"message\":\"Successfully read file docs/harness/EXEC_PLANS.md\",\"content\":\"# Execution Plans\\n\\nExecution plans are self-contained, living design documents for complex multi-step work in VT Code. They capture the goal, context, steps, decisions made during execution, and retrospective notes.\\n\\n## Why Exec Plans?\\n\\n- **Agent continuity**: an agent picking up mid-task can read the exec plan and resume without the original conversation context.\\n- **Decision logging**: captures why choices were made, not just what was done.\\n- **Retrospectives**: completed plans become learning artifacts for future work.\\n\\n## Exec Plans vs Plan Mode\\n\\nThese are distinct concepts:\\n\\n- **Exec Plans** are persistent design documents stored in `docs/harness/exec-plans/`. They capture goals, decisions, and retrospectives for complex work. They survive across sessions.\\n- **Plan Mode** is a runtime safety state in VT Code that blocks mutating tools. It uses `.vtcode/plans/` for ephemeral session plans and has an `exit_plan_mode` tool to transition to implementation.\\n\\nExec Plans are written to `docs/harness/exec-plans/active/` and are part of the repository's knowledge base.\\nPlan Mode session plans are written to `.vtcode/plans/` and are ephemeral per-session artifacts.\\n\\n… [+127 lines omitted; use read_file with offset/limit (1-indexed line numbers) for full content]\\n- From code comments (rare, only for complex architectural changes): `// See EP-NNN`\\n- From tech debt tracker: link to the exec plan in the Description column.\\n\\n## Relationship to Tech Debt Tracker\\n\\nExec plans and tech debt items are complementary:\\n- **Tech debt items** identify what needs fixing (the \\\"what\\\").\\n- **Exec plans** describe how to fix it (the \\\"how\\\").\\n\\nA tech debt item may reference an exec plan. An exec plan may be created to resolve one or more tech debt items.\",\"path\":\"docs/harness/EXEC_PLANS.md\",\"no_spool\":true,\"metadata\":{\"files\":[],\"lines\":[],\"data\":{\"size_bytes\":4610},\"token_counts\":{\"llm_tokens\":0,\"ui_tokens\":0,\"savings_tokens\":0,\"savings_percent\":0.0}}}",
      "tool_call_id": "call_edeb92cb1be14ae794b107cc"
    },
    {
      "role": "System",
      "content": "WARNING: You have performed many consecutive read/search operations in Plan Mode without producing actionable output. Stop browsing, synthesize findings in concise bullets, then use `plan_task_tracker` (`create`/`update`) with concrete steps (files + outcome + verification), or ask one targeted blocking question.",
      "tool_call_id": null
    },
    {
      "role": "Assistant",
      "content": "Let me synthesize findings and create the plan:",
      "tool_call_id": null
    },
    {
      "role": "Tool",
      "content": "{\"error\":\"Tool 'plan_task_tracker' execution failed: Tool execution failed: At least one item is required for 'create'. Provide items: [\\\"step 1\\\", \\\"step 2\\\", ...]\",\"failure_kind\":\"execution\",\"fallback_tool\":\"unified_search\",\"fallback_suggestion\":\"Try 'unified_search' as a fallback approach.\"}",
      "tool_call_id": "call_97d29f227e90445ba2bfa151"
    },
    {
      "role": "Tool",
      "content": "{\"error\":\"Tool 'plan_task_tracker' execution failed: Tool execution failed: At least one item is required for 'create'. Provide items: [\\\"step 1\\\", \\\"step 2\\\", ...]\",\"failure_kind\":\"execution\",\"fallback_tool\":\"unified_search\",\"fallback_suggestion\":\"Try 'unified_search' as a fallback approach.\"}",
      "tool_call_id": "call_966d54e756d74e58997728a4"
    },
    {
      "role": "Tool",
      "content": "{\"error\":\"Tool 'Plan task tracker' is blocked due to excessive repetition (Loop Detected).\",\"failure_kind\":\"loop_detection\"}",
      "tool_call_id": "call_55b64448e99f4c5cb6ed4697"
    },
    {
      "role": "System",
      "content": "Loop detector blocked repeated read-only calls. Use targeted extraction (`grep_file`) or adjust `offset`/`limit` before retrying.",
      "tool_call_id": null
    },
    {
      "role": "Tool",
      "content": "{\"success\":true,\"status\":\"success\",\"message\":\"Successfully wrote file .vtcode/plans/improve-system-prompt.md\",\"mode\":\"fail_if_exists\",\"diff_preview\":{\"content\":\"\\u001b[1m\\u001b[38;2;213;206;182m--- a/.vtcode/plans/improve-system-prompt.md\\n\\u001b[0m\\u001b[1m\\u001b[38;2;213;206;182m+++ b/.vtcode/plans/improve-system-prompt.md\\n\\u001b[0m\\u001b[1m\\u001b[38;2;213;206;182m@@ -1,0 +1,196 @@\\n\\u001b[0m\\u001b[38;2;217;154;78m+# Improve System Prompt \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+This ExecPlan is a living document. Keep Progress, Surprises & Discoveries, \\u001b[0m\\n\\u001b[38;2;217;154;78m+Decision Log, and Outcomes & Retrospective up to date as work proceeds. \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+Reference: `.vtcode/PLANS.md` for full specification. \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+## Purpose / Big Picture \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+Improve the VT Code system prompt to enhance agent effectiveness, reduce token overhead, and ensure consistency with harness engineering principles. The current prompt is well-structured but has opportunities for optimization. \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+## Progress \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+- [ ] Audit current prompt structure and identify improvement areas \\u001b[0m\\n\\u001b[38;2;217;154;78m+- [ ] Consolidate redundant guidance sections \\u001b[0m\\n\\u001b[38;2;217;154;78m+- [ ] Strengthen harness integration references \\u001b[0m\\n\\u001b[38;2;217;154;78m+- [ ] Optimize token efficiency for minimal/lightweight modes \\u001b[0m\\n\\u001b[38;2;217;154;78m+- [ ] Add missing guidance for common failure patterns \\u001b[0m\\n\\u001b[38;2;217;154;78m+- [ ] Update tests to validate improvements \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+## Surprises & Discoveries \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+1. **Current prompt is ~2K tokens** (DEFAULT_SYSTEM_PROMPT) - well within bounds but has redundancy \\u001b[0m\\n\\u001b[38;2;217;154;78m+2. **Four prompt modes exist**: Default, Minimal, Lightweight, Specialized - each serves different use cases \\u001b[0m\\n\\u001b[38;2;217;154;78m+3. **Dynamic guidelines already implemented** in `guidelines.rs` - generates tool-aware guidance \\u001b[0m\\n\\u001b[38;2;217;154;78m+4. **UNIFIED_TOOL_GUIDANCE constant** is shared across prompts - good DRY principle \\u001b[0m\\n\\u001b[38;2;217;154;78m+5. **Structured reasoning tags** (`<analysis>`, `<plan>`, etc.) already included \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+## Decision Log \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+- Decision: Focus on consolidation and clarity rather than major restructuring \\u001b[0m\\n\\u001b[38;2;217;154;78m+  Rationale: Current architecture is sound; improvements should be evolutionary \\u001b[0m\\n\\u001b[38;2;217;154;78m+  Date: 2026-02-24 \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+## Outcomes & Retrospective \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+(To be filled after implementation) \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+## Context and Orientation \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+### Key Files \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+| File | Purpose | \\u001b[0m\\n\\u001b[38;2;217;154;78m+|------|---------| \\u001b[0m\\n\\u001b[38;2;217;154;78m+| `vtcode-core/src/prompts/system.rs` | Main system prompt definitions and composition | \\u001b[0m\\n\\u001b[38;2;217;154;78m+| `vtcode-core/src/prompts/guidelines.rs` | Dynamic tool-aware guidelines generation | \\u001b[0m\\n\\u001b[38;2;217;154;78m+| `vtcode-core/src/prompts/context.rs` | Prompt context structure for dynamic enhancements | \\u001b[0m\\n\\u001b[38;2;217;154;78m+| `docs/harness/CORE_BELIEFS.md` | Foundational principles (Humans Steer, Agents Execute) | \\u001b[0m\\n\\u001b[38;2;217;154;78m+| `docs/harness/ARCHITECTURAL_INVARIANTS.md` | Mechanical rules for code quality | \\u001b[0m\\n\\u001b[38;2;217;154;78m+| `docs/harness/AGENT_LEGIBILITY_GUIDE.md` | Standards for agent-readable output | \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+### Current Prompt Structure \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+``` \\u001b[0m\\n\\u001b[38;2;217;154;78m+DEFAULT_SYSTEM_PROMPT (~2K tokens) \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Core Identity \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Humans Steer, Agents Execute (Pi Pattern) \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Core Principles (5 items) \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Agent Legibility Rule \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Harness Awareness \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Personality & Responsiveness \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Task Execution & Ambition \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Uncertainty Recognition \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Validation & Testing \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Planning (task_tracker) \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Pre-flight Environment Checks \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Tool Guidelines \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Execution Policy & Sandboxing \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Plan Mode (Read-Only) \\u001b[0m\\n\\u001b[38;2;217;154;78m+├── Design Philosophy: Desire Paths \\u001b[0m\\n\\u001b[38;2;217;154;78m+└── Context Management \\u001b[0m\\n\\u001b[38;2;217;154;78m+``` \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+## Identified Improvement Areas \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+### 1. Redundancy Reduction \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+**Issue**: Several sections repeat similar guidance: \\u001b[0m\\n\\u001b[38;2;217;154;78m+- \\\"Bias for action\\\" appears in multiple places \\u001b[0m\\n\\u001b[38;2;217;154;78m+- Tool guidance duplicated between DEFAULT and SPECIALIZED prompts \\u001b[0m\\n\\u001b[38;2;217;154;78m+- \\\"Hallucination of verification\\\" warning repeated \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+**Remediation**: Consolidate into single authoritative sections; use cross-references \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+### 2. Missing Guidance \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+**Issue**: Common failure patterns not explicitly addressed: \\u001b[0m\\n\\u001b[38;2;217;154;78m+- What to do when `apply_patch` fails repeatedly \\u001b[0m\\n\\u001b[38;2;217;154;78m+- How to handle circular dependency detection \\u001b[0m\\n\\u001b[38;2;217;154;78m+- When to escalate vs. when to autonomously pivot \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+**Remediation**: Add explicit failure-mode guidance with decision trees \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n... 71 lines omitted ...\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+### Verification Commands \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+```bash \\u001b[0m\\n\\u001b[38;2;217;154;78m+# Run prompt-related tests \\u001b[0m\\n\\u001b[38;2;217;154;78m+cargo test -p vtcode-core --lib prompts::system::tests \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+# Token estimation (rough: chars / 4) \\u001b[0m\\n\\u001b[38;2;217;154;78m+wc -c vtcode-core/src/prompts/system.rs \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+# Lint check \\u001b[0m\\n\\u001b[38;2;217;154;78m+cargo clippy -p vtcode-core -- -D warnings \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+# Full validation \\u001b[0m\\n\\u001b[38;2;217;154;78m+cargo clippy && cargo fmt --check && cargo check && cargo nextest run \\u001b[0m\\n\\u001b[38;2;217;154;78m+``` \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+## Open Questions \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+1. **Priority Focus**: Should we prioritize token reduction or content enrichment? \\u001b[0m\\n\\u001b[38;2;217;154;78m+   - Option A: Reduce tokens for faster inference \\u001b[0m\\n\\u001b[38;2;217;154;78m+   - Option B: Add more guidance for better agent behavior \\u001b[0m\\n\\u001b[38;2;217;154;78m+   - Option C: Balance both (recommended) \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+2. **Minimal Mode Scope**: Should minimal mode include structured reasoning tags? \\u001b[0m\\n\\u001b[38;2;217;154;78m+   - Current: Yes (~200 token overhead) \\u001b[0m\\n\\u001b[38;2;217;154;78m+   - Alternative: Remove for sub-1K token target \\u001b[0m\\n\\u001b[38;2;217;154;78m+ \\u001b[0m\\n\\u001b[38;2;217;154;78m+3. **Template Approach**: Should output templates be: \\u001b[0m\\n\\u001b[38;2;217;154;78m+   - Inline in prompt (current approach) \\u001b[0m\\n\\u001b[38;2;217;154;78m+   - Separate constants with references \\u001b[0m\\n\\u001b[38;2;217;154;78m+   - External template files loaded dynamically \\u001b[0m\",\"truncated\":true,\"omitted_line_count\":71,\"skipped\":false},\"file_existed\":false,\"path\":\".vtcode/plans/improve-system-prompt.md\",\"bytes_written\":7271}",
      "tool_call_id": "call_1e57822f74c649dea9ddb6e8"
    },
    {
      "role": "Assistant",
      "content": "<uncertainty>\nThe plan is drafted. I need clarification on 3 key decisions before finalizing the implementation approach.\n</uncertainty>\n\nI've analyzed the current system prompt architecture and drafted an improvement plan. The current implementation is well-structured (~2K tokens for default mode) with 4 prompt variants (Default, Minimal, Lightweight, Specialized) and dynamic guidelines generation.\n\n**Key findings:**\n- Redundancy exists between prompt variants (tool guidance, \"bias for action\" warnings)\n- Missing explicit guidance for common failure patterns (patch failures, circular deps)\n- Minimal/Lightweight modes could be further optimized\n- Harness integration is good but could be strengthened with more specific doc refs\n\n**Open questions for alignment:**",
      "tool_call_id": null
    },
    {
      "role": "Tool",
      "content": "{\"error\":\"Tool 'spawn_subagent' execution failed: Failed to generate subagent response\",\"failure_kind\":\"execution\",\"fallback_tool\":\"unified_search\",\"fallback_suggestion\":\"Try 'unified_search' as a fallback approach.\"}",
      "tool_call_id": "call_c8f2f925877b480296bc2896"
    },
    {
      "role": "Tool",
      "content": "{\"cancelled\":true}",
      "tool_call_id": "call_interview_27"
    },
    {
      "role": "Assistant",
      "content": "The plan has been written to `.vtcode/plans/improve-system-prompt.md`. Here are the key decisions I need guidance on:\n\n**Question 1: Priority Focus**\n- **Option A**: Reduce tokens for faster inference (trim redundancy)\n- **Option B**: Add more guidance for better agent behavior (fill gaps)\n- **Option C**: Balance both (consolidate redundancy, add targeted guidance) ← *recommended*\n\n**Question 2: Minimal Mode Scope**\nShould minimal mode include structured reasoning tags (`<analysis>`, `<plan>`, etc.)?\n- Current: Yes (~200 token overhead)\n- Alternative: Remove for sub-1K token target\n\n**Question 3: Template Approach**\nShould output templates be:\n- Inline in prompt (current approach)\n- Separate constants with references (easier to maintain)\n- External template files loaded dynamically (most flexible but adds complexity)\n\nWhich direction would you like me to prioritize?",
      "tool_call_id": null
    },
    {
      "role": "User",
      "content": "option C",
      "tool_call_id": null
    }
  ]
}
````

---

idea: maybe align plan_task_tracker mode with task_tracker as subsystem for agent planning and execution flow.

---

improve system prompt "/Users/vinhnguyenxuan/Developer/learn-by-doing/vtcode/.vtcode/plans/improve-system-prompt-v2.md"

---

for questions, synthesize and gernate llm suggestions differently for eeach questions. currently it
seems they are all have the same questionare?

```

• Questions 3/3 answered
• What user-visible outcome should this change deliver, and what constraints or non-goals must be respe
cted?
╭─ Info ──────────────────────────────────────────────────────────────────────────────────────────────╮
│     answer: Minimal implementation slice (Recommended)                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────╯
• Break the work into 3-7 composable steps. For each step include target file(s) and a concrete expecte
d outcome.
╭─ Info ──────────────────────────────────────────────────────────────────────────────────────────────╮
│     answer: Minimal implementation slice (Recommended)                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────╯
• For each step, what exact command or manual check proves it is complete?
╭─ Info ──────────────────────────────────────────────────────────────────────────────────────────────╮
│     answer: Minimal implementation slice (Recommended)                                              │
╰───────────────────────────────────────────────────────────────────
```

--

check plan errors

```

╭─ Error ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Turn timed out after 660 seconds in phase Requesting. PTY sessions cancelled; Tool activity exists a│
│ nd timeout occurred during LLM requesting; retry is skipped to avoid re-running tools. (calls=25, ac│
│ tive_pty_before_cancel=0)                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─ Error ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Error: Turn timed out after 660 seconds in phase Requesting after partial tool execution (calls=25, │
│ active_pty_before_cancel=0)                                                                         │
╰────────────────────────────────────────────────────────────────────────────────────────────────╯
```

--> it should suggestion user to nudge ("continue") prompt

---

check all modal implementation and unified and extract common. make sure the messages are properly wrapped and styled if needed.

---

use https://git-cliff.org/docs/

---

custom Terminal title (eg: ghostty)
/Users/vinhnguyenxuan/Desktop/terminal_title.png
