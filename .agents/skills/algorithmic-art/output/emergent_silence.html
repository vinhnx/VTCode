<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emergent Silence</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a12;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        main { position: relative; }
        #canvas-container {
            position: relative;
            border: 1px solid rgba(100, 80, 120, 0.3);
            box-shadow: 0 0 60px rgba(30, 20, 50, 0.4);
        }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(180, 160, 200, 0.6);
            font-size: 11px;
            letter-spacing: 0.5px;
        }
        .title {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(180, 160, 200, 0.4);
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <div class="title">Emergent Silence</div>
    <main>
        <div id="canvas-container"></div>
    </main>
    <div class="controls">seed: 2024 | space: reset | click: focus</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script>
    // ═══════════════════════════════════════════════════════════════════════════
    // EMERGENT SILENCE - A Flow Field Particle System
    // ═══════════════════════════════════════════════════════════════════════════
    // Philosophy: Order emerges from chaos through subtle guidance rather than force
    // Particles leave trails that accumulate into patterns
    // Colors: pre-dawn sky - deep indigos to warm ambers
    // ═══════════════════════════════════════════════════════════════════════════

    const SEED = 2024;
    let particles = [];
    let flowField;
    let cols, rows;
    const scl = 20; // Scale of each flow field cell
    let zoff = 0;
    let focusedParticle = null;

    // Color palette: pre-dawn sky
    const palette = [
        [15, 10, 35],    // Deep indigo
        [35, 25, 65],    // Midnight purple
        [55, 35, 85],    // Violet
        [90, 60, 120],   // Lavender
        [140, 100, 130], // Mauve
        [180, 130, 110], // Dusty rose
        [210, 160, 100], // Warm amber
        [230, 200, 150], // Pale gold
    ];

    // Parameters - easy to tune
    const params = {
        particleCount: 800,
        trailFade: 8,        // How quickly trails fade (lower = longer trails)
        flowStrength: 0.15,  // How strongly particles follow the field
        noiseScale: 0.008,   // Scale of the noise field
        timeSpeed: 0.002,    // How fast the field evolves
        maxSpeed: 2,         // Maximum particle speed
        alphaBase: 60,       // Base transparency of particles
    };

    function setup() {
        const size = Math.min(windowWidth - 40, windowHeight - 40, 800);
        const canvas = createCanvas(size, size);
        canvas.parent('canvas-container');

        randomSeed(SEED);
        noiseSeed(SEED);

        cols = floor(width / scl);
        rows = floor(height / scl);
        flowField = new Array(cols * rows);

        initParticles();
    }

    function initParticles() {
        particles = [];
        for (let i = 0; i < params.particleCount; i++) {
            particles.push(new Particle());
        }
    }

    function draw() {
        // Semi-transparent background for trail effect
        background(10, 8, 18, params.trailFade);

        // Update flow field
        let yoff = 0;
        for (let y = 0; y < rows; y++) {
            let xoff = 0;
            for (let x = 0; x < cols; x++) {
                const index = x + y * cols;
                // 3D noise: x, y, time
                const angle = noise(xoff, yoff, zoff) * TWO_PI * 2;
                const v = p5.Vector.fromAngle(angle);
                v.setMag(params.flowStrength);
                flowField[index] = v;
                xoff += params.noiseScale;
            }
            yoff += params.noiseScale;
        }
        zoff += params.timeSpeed;

        // Update and draw particles
        for (let particle of particles) {
            particle.follow(flowField);
            particle.update();
            particle.edges();
            particle.show();
        }

        // Draw focused particle highlight
        if (focusedParticle && focusedParticle.alive) {
            push();
            noFill();
            stroke(255, 200, 100, 150);
            strokeWeight(1);
            ellipse(focusedParticle.pos.x, focusedParticle.pos.y, 20, 20);
            pop();
        }
    }

    function keyPressed() {
        if (key === ' ') {
            initParticles();
            background(10, 8, 18);
        }
    }

    function mousePressed() {
        // Find closest particle to mouse
        let closest = null;
        let closestDist = Infinity;
        for (let particle of particles) {
            const d = dist(mouseX, mouseY, particle.pos.x, particle.pos.y);
            if (d < closestDist) {
                closestDist = d;
                closest = particle;
            }
        }
        if (closest && closestDist < 100) {
            focusedParticle = closest;
        }
    }

    function windowResized() {
        const size = Math.min(windowWidth - 40, windowHeight - 40, 800);
        resizeCanvas(size, size);
        cols = floor(width / scl);
        rows = floor(height / scl);
        flowField = new Array(cols * rows);
        initParticles();
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // PARTICLE CLASS
    // ═══════════════════════════════════════════════════════════════════════════
    class Particle {
        constructor() {
            this.pos = createVector(random(width), random(height));
            this.vel = createVector(0, 0);
            this.acc = createVector(0, 0);
            this.maxSpeed = params.maxSpeed;
            this.prevPos = this.pos.copy();
            this.h = random(palette.length);
            this.life = 255;
            this.alive = true;
        }

        follow(vectors) {
            const x = floor(this.pos.x / scl);
            const y = floor(this.pos.y / scl);
            const index = x + y * cols;
            if (index >= 0 && index < vectors.length) {
                const force = vectors[index];
                this.applyForce(force);
            }
        }

        applyForce(force) {
            this.acc.add(force);
        }

        update() {
            this.vel.add(this.acc);
            this.vel.limit(this.maxSpeed);
            this.pos.add(this.vel);
            this.acc.mult(0);

            // Calculate hue based on position and velocity
            this.h = (noise(this.pos.x * 0.002, this.pos.y * 0.002, zoff * 0.5) * palette.length) % palette.length;

            // Life decay - particles slowly fade
            this.life -= 0.1;
            if (this.life <= 0 || this.pos.x < -50 || this.pos.x > width + 50 ||
                this.pos.y < -50 || this.pos.y > height + 50) {
                this.alive = false;
            }
        }

        show() {
            if (!this.alive) return;

            const col = palette[floor(this.h) % palette.length];
            const alpha = params.alphaBase * (this.life / 255);

            stroke(col[0], col[1], col[2], alpha);
            strokeWeight(1.5);

            if (dist(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y) < 10) {
                line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);
            }

            this.prevPos = this.pos.copy();
        }

        edges() {
            // Wrap around edges
            if (this.pos.x > width) {
                this.pos.x = 0;
                this.updatePrev();
            }
            if (this.pos.x < 0) {
                this.pos.x = width;
                this.updatePrev();
            }
            if (this.pos.y > height) {
                this.pos.y = 0;
                this.updatePrev();
            }
            if (this.pos.y < 0) {
                this.pos.y = height;
                this.updatePrev();
            }
        }

        updatePrev() {
            this.prevPos = this.pos.copy();
        }

        // Respawn particle
        respawn() {
            this.pos = createVector(random(width), random(height));
            this.prevPos = this.pos.copy();
            this.vel = createVector(0, 0);
            this.acc = createVector(0, 0);
            this.life = 255;
            this.alive = true;
        }
    }

    // Periodically respawn dead particles to maintain particle count
    setInterval(() => {
        let deadCount = particles.filter(p => !p.alive).length;
        if (deadCount > 0) {
            for (let particle of particles) {
                if (!particle.alive) {
                    particle.respawn();
                }
            }
        }
    }, 100);
    </script>
</body>
</html>