//! Output item types for Open Responses.
//!
//! Items are the fundamental unit of context in Open Responses. They represent
//! atomic units of model output, tool invocation, or reasoning state.

use serde::{Deserialize, Serialize};
use serde_json::Value;

use super::{ContentPart, ItemStatus};

/// Unique identifier for an output item.
pub type OutputItemId = String;

/// Output items generated by the model.
///
/// Per the Open Responses specification, items are polymorphic (discriminated by `type`),
/// state machines (with status transitions), and streamable (through delta events).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum OutputItem {
    /// A message from the assistant, user, system, or developer.
    Message(MessageItem),

    /// Model reasoning/thinking content.
    Reasoning(ReasoningItem),

    /// A function/tool call request from the model.
    FunctionCall(FunctionCallItem),

    /// Output from a function/tool call execution.
    FunctionCallOutput(FunctionCallOutputItem),

    /// Custom/extension item type (prefixed with implementor slug).
    #[serde(rename = "custom")]
    Custom(CustomItem),
}

impl OutputItem {
    /// Returns the unique identifier for this item.
    pub fn id(&self) -> &str {
        match self {
            Self::Message(m) => &m.id,
            Self::Reasoning(r) => &r.id,
            Self::FunctionCall(f) => &f.id,
            Self::FunctionCallOutput(f) => &f.id,
            Self::Custom(c) => &c.id,
        }
    }

    /// Returns the current status of this item.
    pub fn status(&self) -> ItemStatus {
        match self {
            Self::Message(m) => m.status,
            Self::Reasoning(r) => r.status,
            Self::FunctionCall(f) => f.status,
            Self::FunctionCallOutput(f) => f.status,
            Self::Custom(c) => c.status,
        }
    }

    /// Returns the type name for this item.
    pub fn type_name(&self) -> &str {
        match self {
            Self::Message(_) => "message",
            Self::Reasoning(_) => "reasoning",
            Self::FunctionCall(_) => "function_call",
            Self::FunctionCallOutput(_) => "function_call_output",
            Self::Custom(c) => &c.custom_type,
        }
    }

    /// Creates a new message item with the given parameters.
    pub fn message(id: impl Into<String>, role: MessageRole, content: Vec<ContentPart>) -> Self {
        Self::Message(MessageItem {
            id: id.into(),
            status: ItemStatus::InProgress,
            role,
            content,
        })
    }

    /// Creates a new reasoning item.
    pub fn reasoning(id: impl Into<String>) -> Self {
        Self::Reasoning(ReasoningItem {
            id: id.into(),
            status: ItemStatus::InProgress,
            summary: None,
            content: None,
            encrypted_content: None,
        })
    }

    /// Creates a new function call item.
    pub fn function_call(
        id: impl Into<String>,
        name: impl Into<String>,
        arguments: Value,
    ) -> Self {
        Self::FunctionCall(FunctionCallItem {
            id: id.into(),
            status: ItemStatus::InProgress,
            name: name.into(),
            arguments,
            call_id: None,
        })
    }

    /// Creates a new function call output item.
    pub fn function_call_output(
        id: impl Into<String>,
        call_id: Option<String>,
        output: impl Into<String>,
    ) -> Self {
        Self::FunctionCallOutput(FunctionCallOutputItem {
            id: id.into(),
            status: ItemStatus::InProgress,
            call_id,
            output: output.into(),
        })
    }
}

/// A message item representing conversation content.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MessageItem {
    /// Unique identifier for this item.
    pub id: OutputItemId,

    /// Current lifecycle status.
    pub status: ItemStatus,

    /// Role of the message author.
    pub role: MessageRole,

    /// Content parts that make up this message.
    pub content: Vec<ContentPart>,
}

/// Role of a message author.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
#[serde(rename_all = "lowercase")]
pub enum MessageRole {
    /// User message.
    User,
    /// Assistant/model message.
    #[default]
    Assistant,
    /// System message.
    System,
    /// Developer message (for instructions).
    Developer,
}

impl std::fmt::Display for MessageRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::User => write!(f, "user"),
            Self::Assistant => write!(f, "assistant"),
            Self::System => write!(f, "system"),
            Self::Developer => write!(f, "developer"),
        }
    }
}

/// A reasoning item containing model's internal thought process.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReasoningItem {
    /// Unique identifier for this item.
    pub id: OutputItemId,

    /// Current lifecycle status.
    pub status: ItemStatus,

    /// Summary of the reasoning (human-readable).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,

    /// Raw reasoning trace content.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,

    /// Encrypted reasoning content for rehydration.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encrypted_content: Option<String>,
}

/// A function call item representing a tool invocation request.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FunctionCallItem {
    /// Unique identifier for this item.
    pub id: OutputItemId,

    /// Current lifecycle status.
    pub status: ItemStatus,

    /// Name of the function to call.
    pub name: String,

    /// Arguments to pass to the function (JSON object).
    pub arguments: Value,

    /// Optional call ID for correlating with output.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub call_id: Option<String>,
}

/// Output from a function call execution.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FunctionCallOutputItem {
    /// Unique identifier for this item.
    pub id: OutputItemId,

    /// Current lifecycle status.
    pub status: ItemStatus,

    /// ID of the function call this output corresponds to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub call_id: Option<String>,

    /// Output content from the function execution.
    pub output: String,
}

/// Custom/extension item type.
///
/// Custom types must be prefixed with an implementor slug (e.g., `vtcode:file_change`).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CustomItem {
    /// Unique identifier for this item.
    pub id: OutputItemId,

    /// Current lifecycle status.
    pub status: ItemStatus,

    /// Custom type identifier (must be prefixed, e.g., `vtcode:file_change`).
    pub custom_type: String,

    /// Custom data payload.
    pub data: Value,
}

impl CustomItem {
    /// Creates a new custom item with VT Code prefix.
    pub fn vtcode(id: impl Into<String>, name: &str, data: Value) -> Self {
        Self {
            id: id.into(),
            status: ItemStatus::InProgress,
            custom_type: format!("vtcode:{name}"),
            data,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_output_item_id() {
        let item = OutputItem::message("msg_1", MessageRole::Assistant, vec![]);
        assert_eq!(item.id(), "msg_1");
        assert_eq!(item.type_name(), "message");
    }

    #[test]
    fn test_function_call_serialization() {
        let item = OutputItem::function_call(
            "fc_1",
            "read_file",
            serde_json::json!({"path": "/etc/passwd"}),
        );
        let json = serde_json::to_string(&item).unwrap();
        assert!(json.contains("\"type\":\"function_call\""));
        assert!(json.contains("\"name\":\"read_file\""));
    }

    #[test]
    fn test_custom_item_vtcode() {
        let item = CustomItem::vtcode(
            "custom_1",
            "file_change",
            serde_json::json!({"path": "test.rs", "kind": "update"}),
        );
        assert_eq!(item.custom_type, "vtcode:file_change");
    }
}
